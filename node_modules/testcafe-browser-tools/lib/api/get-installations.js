'use strict';

var _regeneratorRuntime = require('babel-runtime/regenerator').default;

var _Object$keys = require('babel-runtime/core-js/object/keys').default;

var _Object$assign = require('babel-runtime/core-js/object/assign').default;

var _interopRequireDefault = require('babel-runtime/helpers/interop-require-default').default;

exports.__esModule = true;

var _pinkie = require('pinkie');

var _pinkie2 = _interopRequireDefault(_pinkie);

var _osFamily = require('os-family');

var _osFamily2 = _interopRequireDefault(_osFamily);

var _whichPromise = require('which-promise');

var _whichPromise2 = _interopRequireDefault(_whichPromise);

var _utilsFsExistsPromised = require('../utils/fs-exists-promised');

var _utilsFsExistsPromised2 = _interopRequireDefault(_utilsFsExistsPromised);

var _utilsExec = require('../utils/exec');

var _aliases = require('../aliases');

var _aliases2 = _interopRequireDefault(_aliases);

// Installation info cache
var installationsCache = null;

// Find installations for different platforms
function addInstallation(installations, name, instPath) {
    var fileExists;
    return _regeneratorRuntime.async(function addInstallation$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                context$1$0.next = 2;
                return _regeneratorRuntime.awrap(_utilsFsExistsPromised2.default(instPath));

            case 2:
                fileExists = context$1$0.sent;

                if (fileExists) {
                    _Object$keys(_aliases2.default).some(function (alias) {
                        var _ALIASES$alias = _aliases2.default[alias];
                        var nameRe = _ALIASES$alias.nameRe;
                        var cmd = _ALIASES$alias.cmd;
                        var macOpenCmdTemplate = _ALIASES$alias.macOpenCmdTemplate;
                        var path = _ALIASES$alias.path;

                        if (nameRe.test(name)) {
                            installations[alias] = { path: path || instPath, cmd: cmd, macOpenCmdTemplate: macOpenCmdTemplate };
                            return true;
                        }

                        return false;
                    });
                }

            case 4:
            case 'end':
                return context$1$0.stop();
        }
    }, null, this);
}

function detectMicrosoftEdge() {
    var regKey, stdout;
    return _regeneratorRuntime.async(function detectMicrosoftEdge$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                regKey = 'HKCU\\Software\\Classes\\ActivatableClasses';
                context$1$0.next = 3;
                return _regeneratorRuntime.awrap(_utilsExec.execWinShellUtf8('@echo off & reg query ' + regKey + ' /s /f MicrosoftEdge /k && echo SUCCESS || echo FAIL'));

            case 3:
                stdout = context$1$0.sent;
                return context$1$0.abrupt('return', /SUCCESS/.test(stdout) ? _aliases2.default['edge'] : null);

            case 5:
            case 'end':
                return context$1$0.stop();
        }
    }, null, this);
}

function searchInRegistry(registryRoot) {
    var installations, regKey, regKeyEsc, browserRe, stdout, match, name, path;
    return _regeneratorRuntime.async(function searchInRegistry$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                installations = {};
                regKey = registryRoot + '\\SOFTWARE\\Clients\\StartMenuInternet';
                regKeyEsc = regKey.replace(/\\/g, '\\\\');
                browserRe = new RegExp(regKeyEsc + '\\\\([^\\\\]+)\\\\shell\\\\open\\\\command' + '\\s+(?:\\([^)]+\\)|<.*?>)\\s+reg_sz\\s+([^\n]+)\n', 'gi');
                context$1$0.next = 6;
                return _regeneratorRuntime.awrap(_utilsExec.execWinShellUtf8('reg query ' + regKey + ' /s'));

            case 6:
                stdout = context$1$0.sent;
                match = browserRe.exec(stdout);

            case 8:
                if (!match) {
                    context$1$0.next = 16;
                    break;
                }

                name = match[1].replace(/\.exe$/gi, '');
                path = match[2].replace(/"/g, '').replace(/\\$/, '').replace(/\s*$/, '');
                context$1$0.next = 13;
                return _regeneratorRuntime.awrap(addInstallation(installations, name, path));

            case 13:
                match = browserRe.exec(stdout);
                context$1$0.next = 8;
                break;

            case 16:
                return context$1$0.abrupt('return', installations);

            case 17:
            case 'end':
                return context$1$0.stop();
        }
    }, null, this);
}

function findWindowsBrowsers() {
    var machineRegisteredBrowsers, userRegisteredBrowsers, installations, edgeAlias;
    return _regeneratorRuntime.async(function findWindowsBrowsers$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                context$1$0.next = 2;
                return _regeneratorRuntime.awrap(searchInRegistry('HKEY_LOCAL_MACHINE'));

            case 2:
                machineRegisteredBrowsers = context$1$0.sent;
                context$1$0.next = 5;
                return _regeneratorRuntime.awrap(searchInRegistry('HKEY_CURRENT_USER'));

            case 5:
                userRegisteredBrowsers = context$1$0.sent;
                installations = _Object$assign(machineRegisteredBrowsers, userRegisteredBrowsers);
                context$1$0.next = 9;
                return _regeneratorRuntime.awrap(detectMicrosoftEdge());

            case 9:
                edgeAlias = context$1$0.sent;

                if (edgeAlias) installations['edge'] = edgeAlias;

                return context$1$0.abrupt('return', installations);

            case 12:
            case 'end':
                return context$1$0.stop();
        }
    }, null, this);
}

function findMacBrowsers() {
    var installations, stdout;
    return _regeneratorRuntime.async(function findMacBrowsers$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                installations = {};
                context$1$0.next = 3;
                return _regeneratorRuntime.awrap(_utilsExec.exec('ls "/Applications/" | grep -E "Chrome|Firefox|Opera|Safari|Chromium" | sed -E "s/ /032/"'));

            case 3:
                stdout = context$1$0.sent;
                context$1$0.next = 6;
                return _regeneratorRuntime.awrap(_pinkie2.default.all(stdout.split('\n').filter(function (fileName) {
                    return !!fileName;
                }).map(function (fileName) {
                    // NOTE: restore space
                    fileName = fileName.replace(/032/g, ' ');

                    var name = fileName.replace(/.app$/, '');
                    var path = '/Applications/' + fileName;

                    return addInstallation(installations, name, path);
                })));

            case 6:
                return context$1$0.abrupt('return', installations);

            case 7:
            case 'end':
                return context$1$0.stop();
        }
    }, null, this);
}

function findLinuxBrowsers() {
    var installations, aliasCheckingPromises;
    return _regeneratorRuntime.async(function findLinuxBrowsers$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                installations = {};
                aliasCheckingPromises = _Object$keys(_aliases2.default).map(function (name) {
                    var linuxBinaries = _aliases2.default[name].linuxBinaries;

                    if (!linuxBinaries) return null;

                    var detectionPromises = linuxBinaries.map(function (binary) {
                        return _whichPromise2.default(binary).then(function (path) {
                            return addInstallation(installations, name, path);
                        }).catch(function () {
                            // NOTE: binary not found, just do nothing
                            return;
                        });
                    });

                    return _pinkie2.default.all(detectionPromises);
                });
                context$1$0.next = 4;
                return _regeneratorRuntime.awrap(_pinkie2.default.all(aliasCheckingPromises));

            case 4:
                return context$1$0.abrupt('return', installations);

            case 5:
            case 'end':
                return context$1$0.stop();
        }
    }, null, this);
}

function findBrowsers() {
    return _regeneratorRuntime.async(function findBrowsers$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                if (!_osFamily2.default.win) {
                    context$1$0.next = 4;
                    break;
                }

                context$1$0.next = 3;
                return _regeneratorRuntime.awrap(findWindowsBrowsers());

            case 3:
                return context$1$0.abrupt('return', context$1$0.sent);

            case 4:
                if (!_osFamily2.default.mac) {
                    context$1$0.next = 8;
                    break;
                }

                context$1$0.next = 7;
                return _regeneratorRuntime.awrap(findMacBrowsers());

            case 7:
                return context$1$0.abrupt('return', context$1$0.sent);

            case 8:
                if (!_osFamily2.default.linux) {
                    context$1$0.next = 12;
                    break;
                }

                context$1$0.next = 11;
                return _regeneratorRuntime.awrap(findLinuxBrowsers());

            case 11:
                return context$1$0.abrupt('return', context$1$0.sent);

            case 12:
            case 'end':
                return context$1$0.stop();
        }
    }, null, this);
}

// API
/** @typedef {Object} BrowserInfo
 * @description Object that contains information about the browser installed on the machine.
 * @property {string|undefined} path - The path to the executable file that starts the browser.
 *  Required on MacOS machines. On Windows machines, it is used when the winOpenCmdTemplate property is undefined.
 * @property {string} cmd - Additional command line parameters.
 * @property {string} macOpenCmdTemplate - A [Mustache template](https://github.com/janl/mustache.js#templates)
 *  that provides parameters for launching the browser on a MacOS machine.
 * @property {string|undefined} winOpenCmdTemplate - A [Mustache template](https://github.com/janl/mustache.js#templates)
 *  that provides parameters for launching the browser on a Windows machine.  If undefined, the path to the
 *  executable file specified by the path property is used.
 * @example
 *  {
 *       path: 'C:\\ProgramFiles\\...\\firefox.exe',
 *       cmd: '-new-window',
 *       macOpenCmdTemplate: 'open -a "{{{path}}}" {{{pageUrl}}} --args {{{cmd}}}'
 *  }
 */

/**
 * Returns the list of the {@link BrowserInfo} objects that contain information about the browsers installed on the machine.
 * @function
 * @async
 * @name getInstallations
 * @returns {Object.<string, BrowserInfo>} List of the {@link BrowserInfo} objects
 *   containing information about the browsers installed on the machine.
 * @example
 * {
 *   chrome: {
 *       path: 'C:\\ProgramFiles\\...\\chrome.exe',
 *       cmd: '--new-window',
 *       macOpenCmdTemplate: 'open -n -a "{{{path}}}" --args {{{pageUrl}}} {{{cmd}}}'
 *   },
 *
 *   firefox: {
 *       path: 'C:\\ProgramFiles\\...\\firefox.exe',
 *       cmd: '-new-window',
 *       macOpenCmdTemplate: 'open -a "{{{path}}}" {{{pageUrl}}} --args {{{cmd}}}'
 *   }
 * }
 */

exports.default = function callee$0$0() {
    return _regeneratorRuntime.async(function callee$0$0$(context$1$0) {
        while (1) switch (context$1$0.prev = context$1$0.next) {
            case 0:
                if (installationsCache) {
                    context$1$0.next = 4;
                    break;
                }

                context$1$0.next = 3;
                return _regeneratorRuntime.awrap(findBrowsers());

            case 3:
                installationsCache = context$1$0.sent;

            case 4:
                return context$1$0.abrupt('return', installationsCache);

            case 5:
            case 'end':
                return context$1$0.stop();
        }
    }, null, this);
};

module.exports = exports.default;

// NOTE: To get the correct result regardless of the Windows localization,
// we need to run the command using the UTF-8 codepage.

// NOTE: replace the space symbol with code, because grep splits strings by space.