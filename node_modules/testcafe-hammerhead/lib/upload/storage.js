'use strict';

exports.__esModule = true;

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _mime = require('mime');

var _mime2 = _interopRequireDefault(_mime);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _util = require('util');

var _promisify = require('../utils/promisify');

var _promisify2 = _interopRequireDefault(_promisify);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const readFile = (0, _promisify2.default)(_fs2.default.readFile);
const stat = (0, _promisify2.default)(_fs2.default.stat);
const readDir = (0, _promisify2.default)(_fs2.default.readdir);
const makeDir = (0, _promisify2.default)(_fs2.default.mkdir);
const writeFile = (0, _promisify2.default)(_fs2.default.writeFile);
const exists = fsPath => stat(fsPath).then(() => true, () => false);

class UploadStorage {
    constructor(uploadsRoot) {
        this.uploadsRoot = uploadsRoot;
    }

    static _getFilesToCopy(files) {
        return _asyncToGenerator(function* () {
            const filesToCopy = [];
            const errs = [];

            for (var _iterator = files, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
                var _ref;

                if (_isArray) {
                    if (_i >= _iterator.length) break;
                    _ref = _iterator[_i++];
                } else {
                    _i = _iterator.next();
                    if (_i.done) break;
                    _ref = _i.value;
                }

                const file = _ref;

                try {
                    const stats = yield stat(file.path);

                    if (stats.isFile()) filesToCopy.push(file);
                } catch (err) {
                    errs.push({ path: file.path, err });
                }
            }

            return { filesToCopy, errs };
        })();
    }

    static _generateName(existingNames, fileName) {
        const extName = _path2.default.extname(fileName);
        const template = _path2.default.basename(fileName, extName) + ' %s' + extName;
        let index = 0;

        while (existingNames.includes(fileName)) fileName = (0, _util.format)(template, ++index);

        return fileName;
    }

    static _getExistingFiles(uploadsRoot) {
        return _asyncToGenerator(function* () {
            try {
                return yield readDir(uploadsRoot);
            } catch (e) {
                return [];
            }
        })();
    }

    store(fileNames, data) {
        var _this = this;

        return _asyncToGenerator(function* () {
            const storedFiles = [];
            const err = yield UploadStorage.ensureUploadsRoot(_this.uploadsRoot);

            if (err) return [{ err: err.toString(), path: _this.uploadsRoot }];

            const existingFiles = yield UploadStorage._getExistingFiles(_this.uploadsRoot);

            for (var _iterator2 = fileNames, _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
                var _ref2;

                if (_isArray2) {
                    if (_i2 >= _iterator2.length) break;
                    _ref2 = _iterator2[_i2++];
                } else {
                    _i2 = _iterator2.next();
                    if (_i2.done) break;
                    _ref2 = _i2.value;
                }

                const fileName = _ref2;

                const storedFileName = UploadStorage._generateName(existingFiles, fileName);
                const storedFilePath = _path2.default.join(_this.uploadsRoot, storedFileName);

                try {
                    yield writeFile(storedFilePath, data[storedFiles.length], { encoding: 'base64' });

                    existingFiles.push(storedFileName);
                    storedFiles.push({ path: storedFilePath, file: storedFileName });
                } catch (e) {
                    storedFiles.push({ err: e.toString(), path: storedFilePath, file: fileName });
                }
            }

            return storedFiles;
        })();
    }

    get(filePathList) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            const result = [];

            for (var _iterator3 = filePathList, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
                var _ref3;

                if (_isArray3) {
                    if (_i3 >= _iterator3.length) break;
                    _ref3 = _iterator3[_i3++];
                } else {
                    _i3 = _iterator3.next();
                    if (_i3.done) break;
                    _ref3 = _i3.value;
                }

                const filePath = _ref3;

                const resolvedPath = _path2.default.resolve(_this2.uploadsRoot, filePath);

                try {
                    const fileContent = yield readFile(resolvedPath);
                    const fileStats = yield stat(resolvedPath);

                    result.push({
                        data: fileContent.toString('base64'),
                        info: {
                            lastModifiedDate: fileStats.mtime,
                            name: _path2.default.basename(resolvedPath),
                            type: _mime2.default.lookup(resolvedPath)
                        }
                    });
                } catch (e) {
                    result.push({ err: e.toString(), path: filePath, resolvedPath });
                }
            }

            return result;
        })();
    }

    static copy(uploadsRoot, files) {
        return _asyncToGenerator(function* () {
            var _ref4 = yield UploadStorage._getFilesToCopy(files);

            const filesToCopy = _ref4.filesToCopy,
                  errs = _ref4.errs;

            const copiedFiles = [];

            if (!filesToCopy.length) return { copiedFiles, errs };

            const existingFiles = yield UploadStorage._getExistingFiles(uploadsRoot);

            for (var _iterator4 = filesToCopy, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
                var _ref5;

                if (_isArray4) {
                    if (_i4 >= _iterator4.length) break;
                    _ref5 = _iterator4[_i4++];
                } else {
                    _i4 = _iterator4.next();
                    if (_i4.done) break;
                    _ref5 = _i4.value;
                }

                const file = _ref5;

                const copiedFileName = UploadStorage._generateName(existingFiles, file.name);
                const copiedFilePath = _path2.default.join(uploadsRoot, copiedFileName);

                try {
                    yield writeFile(copiedFilePath, (yield readFile(file.path, null)));

                    existingFiles.push(copiedFileName);
                    copiedFiles.push(copiedFilePath);
                } catch (err) {
                    errs.push({ path: file.path, err });
                }
            }

            return { copiedFiles, errs };
        })();
    }

    static ensureUploadsRoot(uploadsRoot) {
        return _asyncToGenerator(function* () {
            try {
                if (!(yield exists(uploadsRoot))) yield makeDir(uploadsRoot);

                return null;
            } catch (err) {
                return err;
            }
        })();
    }
}
exports.default = UploadStorage;
module.exports = exports['default'];