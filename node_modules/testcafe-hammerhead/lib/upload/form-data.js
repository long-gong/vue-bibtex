'use strict';

exports.__esModule = true;

var _internalAttributes = require('../processing/dom/internal-attributes');

var _internalAttributes2 = _interopRequireDefault(_internalAttributes);

var _formDataEntry = require('./form-data-entry');

var _formDataEntry2 = _interopRequireDefault(_formDataEntry);

var _buffer = require('../utils/buffer');

var bufferUtils = _interopRequireWildcard(_buffer);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Const
const BOUNDARY_RE = /;\s*boundary=([^;]*)/i;

const PARSER_STATE = {
    inPreamble: 'IN_PREAMBLE',
    inHeaders: 'IN_HEADERS',
    inBody: 'IN_BODY',
    inEpilogue: 'IN_EPILOGUE'
};

// Form data
class FormData {
    constructor() {
        this.boundary = null;
        this.boundaryEnd = null;
        this.epilogue = [];
        this.entries = [];
        this.preamble = [];
    }

    _removeEntry(name) {
        this.entries = this.entries.filter(entry => entry.name !== name);
    }

    _injectFileInfo(fileInfo) {
        const entries = this.getEntriesByName(fileInfo.name);

        for (let idx = 0; idx < fileInfo.files.length; idx++) {
            let entry = entries[idx];

            if (!entry) {
                entry = new _formDataEntry2.default();

                this.entries.push(entry);
            }

            entry.addFileInfo(fileInfo, idx);
        }
    }

    _isBoundary(line) {
        return bufferUtils.equals(this.boundary, line);
    }

    _isBoundaryEnd(line) {
        return bufferUtils.equals(this.boundaryEnd, line);
    }

    getEntriesByName(name) {
        return this.entries.reduce((found, entry) => {
            if (entry.name === name) found.push(entry);

            return found;
        }, []);
    }

    expandUploads() {
        const uploadsEntry = this.getEntriesByName(_internalAttributes2.default.uploadInfoHiddenInputName)[0];

        if (uploadsEntry) {
            const body = Buffer.concat(uploadsEntry.body).toString();
            const files = JSON.parse(body);

            this._removeEntry(_internalAttributes2.default.uploadInfoHiddenInputName);
            files.forEach(fileInfo => this._injectFileInfo(fileInfo));
        }
    }

    parseContentTypeHeader(header) {
        header = String(header);

        if (header.includes('multipart/form-data')) {
            const boundaryMatch = header.match(BOUNDARY_RE);
            const token = boundaryMatch && boundaryMatch[1];

            if (token) {
                this.boundary = Buffer.from('--' + token);
                this.boundaryEnd = Buffer.from('--' + token + '--');
            }
        }
    }

    parseBody(body) {
        let state = PARSER_STATE.inPreamble;
        const lines = bufferUtils.createLineIterator(body);
        let currentEntry = null;

        for (var _iterator = lines, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
            var _ref;

            if (_isArray) {
                if (_i >= _iterator.length) break;
                _ref = _iterator[_i++];
            } else {
                _i = _iterator.next();
                if (_i.done) break;
                _ref = _i.value;
            }

            const line = _ref;

            if (this._isBoundary(line)) {
                if (currentEntry) this.entries.push(currentEntry);

                state = PARSER_STATE.inHeaders;
                currentEntry = new _formDataEntry2.default();
            } else if (this._isBoundaryEnd(line)) {
                if (currentEntry) this.entries.push(currentEntry);

                state = PARSER_STATE.inEpilogue;
            } else if (state === PARSER_STATE.inPreamble) bufferUtils.appendLine(this.preamble, line);else if (state === PARSER_STATE.inHeaders) {
                if (line.length) currentEntry.setHeader(line.toString());else state = PARSER_STATE.inBody;
            } else if (state === PARSER_STATE.inEpilogue) bufferUtils.appendLine(this.epilogue, line);else if (state === PARSER_STATE.inBody) bufferUtils.appendLine(currentEntry.body, line);
        }
    }

    toBuffer() {
        let chunks = this.preamble;

        if (chunks.length) chunks.push(bufferUtils.CRLF);

        this.entries.forEach(entry => {
            chunks.push(this.boundary, bufferUtils.CRLF, entry.toBuffer(), bufferUtils.CRLF);
        });

        chunks.push(this.boundaryEnd, bufferUtils.CRLF);

        chunks = chunks.concat(this.epilogue);

        return Buffer.concat(chunks);
    }
}
exports.default = FormData;
module.exports = exports['default'];