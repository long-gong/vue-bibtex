"use strict";

var _state = require("./state");

var _util = require("./util");

var pp = _state.Parser.prototype;

// Object.assign polyfill
var assign = Object.assign || function (target, ...sources) {
  for (var _iterator = sources, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
    var _ref;

    if (_isArray) {
      if (_i >= _iterator.length) break;
      _ref = _iterator[_i++];
    } else {
      _i = _iterator.next();
      if (_i.done) break;
      _ref = _i.value;
    }

    var source = _ref;

    for (var key in source) {
      if ((0, _util.has)(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};

// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.

pp.enterFunctionScope = function () {
  // var: a hash of var-declared names in the current lexical scope
  // lexical: a hash of lexically-declared names in the current lexical scope
  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)
  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)
  this.scopeStack.push({ var: {}, lexical: {}, childVar: {}, parentLexical: {} });
};

pp.exitFunctionScope = function () {
  this.scopeStack.pop();
};

pp.enterLexicalScope = function () {
  var parentScope = this.scopeStack[this.scopeStack.length - 1];
  var childScope = { var: {}, lexical: {}, childVar: {}, parentLexical: {} };

  this.scopeStack.push(childScope);
  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);
};

pp.exitLexicalScope = function () {
  var childScope = this.scopeStack.pop();
  var parentScope = this.scopeStack[this.scopeStack.length - 1];

  assign(parentScope.childVar, childScope.var, childScope.childVar);
};

/**
 * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`
 * in the current lexical scope or any of the parent lexical scopes in this function.
 */
pp.canDeclareVarName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !(0, _util.has)(currentScope.lexical, name) && !(0, _util.has)(currentScope.parentLexical, name);
};

/**
 * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`
 * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in
 * any child lexical scopes in this function.
 */
pp.canDeclareLexicalName = function (name) {
  var currentScope = this.scopeStack[this.scopeStack.length - 1];

  return !(0, _util.has)(currentScope.lexical, name) && !(0, _util.has)(currentScope.var, name) && !(0, _util.has)(currentScope.childVar, name);
};

pp.declareVarName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].var[name] = true;
};

pp.declareLexicalName = function (name) {
  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;
};