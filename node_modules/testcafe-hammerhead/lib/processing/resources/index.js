'use strict';

exports.__esModule = true;
exports.process = undefined;

let process = exports.process = (() => {
    var _ref = _asyncToGenerator(function* (ctx) {
        const processors = [_page2.default, _manifest2.default, _script2.default, _stylesheet2.default];
        const body = ctx.destResBody;
        const contentInfo = ctx.contentInfo;
        const encoding = contentInfo.encoding;
        const charset = contentInfo.charset;

        const decoded = yield (0, _encoding.decodeContent)(body, encoding, charset);

        for (let i = 0; i < processors.length; i++) {
            if (processors[i].shouldProcessResource(ctx)) {
                const urlReplacer = getResourceUrlReplacer(ctx);
                const processed = processors[i].processResource(decoded, ctx, charset, urlReplacer);

                if (processed === _page2.default.RESTART_PROCESSING) return yield process(ctx);

                return yield (0, _encoding.encodeContent)(processed, encoding, charset);
            }
        }

        return body;
    });

    return function process(_x) {
        return _ref.apply(this, arguments);
    };
})();

var _url = require('url');

var _url2 = _interopRequireDefault(_url);

var _page = require('./page');

var _page2 = _interopRequireDefault(_page);

var _manifest = require('./manifest');

var _manifest2 = _interopRequireDefault(_manifest);

var _script = require('./script');

var _script2 = _interopRequireDefault(_script);

var _stylesheet = require('./stylesheet');

var _stylesheet2 = _interopRequireDefault(_stylesheet);

var _url3 = require('../../utils/url');

var urlUtil = _interopRequireWildcard(_url3);

var _encoding = require('../encoding');

var _os = require('os');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const IS_WIN = (0, _os.platform)() === 'win32';
const DISK_RE = /^[A-Za-z]:/;

function getResourceUrlReplacer(ctx) {
    return function (resourceUrl, resourceType, charsetAttrValue, baseUrl) {
        if (!urlUtil.isSupportedProtocol(resourceUrl) && !urlUtil.isSpecialPage(resourceUrl)) return resourceUrl;

        if (IS_WIN && ctx.dest.protocol === 'file:' && DISK_RE.test(resourceUrl)) resourceUrl = '/' + resourceUrl;

        // NOTE: Resolves base URLs without a protocol ('//google.com/path' for example).
        baseUrl = baseUrl ? _url2.default.resolve(ctx.dest.url, baseUrl) : '';
        resourceUrl = urlUtil.processSpecialChars(resourceUrl);

        let resolvedUrl = _url2.default.resolve(baseUrl || ctx.dest.url, resourceUrl);

        if (!urlUtil.isValidUrl(resolvedUrl)) return resourceUrl;

        const isScript = urlUtil.parseResourceType(resourceType).isScript;
        const charsetStr = charsetAttrValue || isScript && ctx.contentInfo.charset.get();

        resolvedUrl = urlUtil.ensureTrailingSlash(resourceUrl, resolvedUrl);

        if (!urlUtil.isValidUrl(resolvedUrl)) return resolvedUrl;

        return ctx.toProxyUrl(resolvedUrl, false, resourceType, charsetStr);
    };
}