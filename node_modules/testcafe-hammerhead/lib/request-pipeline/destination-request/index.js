'use strict';

exports.__esModule = true;

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _lodash = require('lodash');

var _semver = require('semver');

var _semver2 = _interopRequireDefault(_semver);

var _agent = require('./agent');

var requestAgent = _interopRequireWildcard(_agent);

var _events = require('events');

var _webauth = require('webauth');

var _connectionResetGuard = require('../connection-reset-guard');

var _connectionResetGuard2 = _interopRequireDefault(_connectionResetGuard);

var _messages = require('../../messages');

var _headerTransforms = require('../header-transforms');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

// HACK: Ignore SSL auth. The rejectUnauthorized option in the https.request method
// doesn't work (see: https://github.com/mikeal/request/issues/418).
process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';

const TUNNELING_SOCKET_ERR_RE = /tunneling socket could not be established/i;
const TUNNELING_AUTHORIZE_ERR_RE = /statusCode=407/i;
const SOCKET_HANG_UP_ERR_RE = /socket hang up/i;
const IS_DNS_ERR_MSG_RE = /ECONNREFUSED|ENOTFOUND|EPROTO/;
const IS_DNS_ERR_CODE_RE = /ECONNRESET/;

// NOTE: Starting from 8.6 version, Node.js changes behavior related with sending requests
// to sites using SSL2 and SSL3 protocol versions. It affects the https core module
// and can break a proxying of some sites. This is why, we are forced to use the special hack.
// For details, see https://github.com/nodejs/node/issues/16196
const IS_NODE_VERSION_GREATER_THAN_8_5 = _semver2.default.gt(process.version, '8.5.0');

// DestinationRequest
class DestinationRequest extends _events.EventEmitter {
    constructor(opts) {
        super();

        this.req = null;
        this.hasResponse = false;
        this.credentialsSent = false;
        this.aborted = false;
        this.opts = opts;
        this.isHttps = opts.protocol === 'https:';
        this.protocolInterface = this.isHttps ? _https2.default : _http2.default;

        // NOTE: Ignore SSL auth.
        if (this.isHttps) {
            opts.rejectUnauthorized = false;

            if (IS_NODE_VERSION_GREATER_THAN_8_5) opts.ecdhCurve = 'auto';
        }

        requestAgent.assign(this.opts);
        this._send();
    }

    _send(waitForData) {
        (0, _connectionResetGuard2.default)(() => {
            const timeout = this.opts.isXhr ? DestinationRequest.XHR_TIMEOUT : DestinationRequest.TIMEOUT;
            const storedHeaders = this.opts.headers;

            // NOTE: The headers are converted to raw headers because some sites ignore headers in a lower case. (GH-1380)
            // We also need to restore the request option headers to a lower case because headers may change
            // if a request is unauthorized, so there can be duplicated headers, for example, 'www-authenticate' and 'WWW-Authenticate'.
            this.opts.headers = (0, _headerTransforms.transformHeadersCaseToRaw)(this.opts.headers, this.opts.rawHeaders);
            this.req = this.protocolInterface.request(this.opts, res => {
                if (waitForData) {
                    res.on('data', _lodash.noop);
                    res.once('end', () => this._onResponse(res));
                }
            });
            this.opts.headers = storedHeaders;

            if (!waitForData) this.req.on('response', res => this._onResponse(res));

            this.req.on('error', err => this._onError(err));
            this.req.on('upgrade', (res, socket, head) => this._onUpgrade(res, socket, head));
            this.req.setTimeout(timeout, () => this._onTimeout());
            this.req.write(this.opts.body);
            this.req.end();
        });
    }

    _shouldResendWithCredentials(res) {
        if (res.statusCode === 401 && this.opts.credentials) {
            const authInfo = (0, _webauth.getAuthInfo)(res);

            // NOTE: If we get 401 status code after credentials are sent, we should stop trying to authenticate.
            if (!authInfo.isChallengeMessage && this.credentialsSent) return false;

            return authInfo.canAuthorize;
        }

        return false;
    }

    _onResponse(res) {
        if (this._shouldResendWithCredentials(res)) this._resendWithCredentials(res);else if (!this.isHttps && this.opts.proxy && res.statusCode === 407) this._fatalError(_messages.MESSAGE.cantAuthorizeToProxy, this.opts.proxy.host);else {
            this.hasResponse = true;
            this.emit('response', res);
        }
    }

    _onUpgrade(res, socket, head) {
        if (head && head.length) socket.unshift(head);

        this._onResponse(res);
    }

    _resendWithCredentials(res) {
        var _this = this;

        return _asyncToGenerator(function* () {
            (0, _webauth.addCredentials)(_this.opts.credentials, _this.opts, res, _this.protocolInterface);
            _this.credentialsSent = true;

            // NOTE: NTLM authentication requires using the same socket for the "negotiate" and "authenticate" requests.
            // So, before sending the "authenticate" message, we should wait for data from the "challenge" response. It
            // will mean that the socket is free.
            _this._send((0, _webauth.requiresResBody)(res));
        })();
    }

    _fatalError(msg, url) {
        if (!this.aborted) {
            this.aborted = true;
            this.req.abort();
            this.emit('fatalError', (0, _messages.getText)(msg, url || this.opts.url));
        }
    }

    _isDNSErr(err) {
        return err.message && IS_DNS_ERR_MSG_RE.test(err.message) || !this.aborted && !this.hasResponse && err.code && IS_DNS_ERR_CODE_RE.test(err.code);
    }

    _isTunnelingErr(err) {
        return this.isHttps && this.opts.proxy && err.message && TUNNELING_SOCKET_ERR_RE.test(err.message);
    }

    _isSocketHangUpErr(err) {
        return err.message && SOCKET_HANG_UP_ERR_RE.test(err.message) &&
        // NOTE: Only for nodejs 4 error with a same message will be generated for different cases.
        // This is why, we filter a 'SocketHangUpErr' by stack.
        // Remove filtering by stack content after ending support of nodejs 4.
        err.stack && err.stack.includes('createHangUpError');
    }

    _onTimeout() {
        // NOTE: this handler is also called if we get an error response (for example, 404). So, we should check
        // for the response presence before raising the timeout error.
        if (!this.hasResponse) this._fatalError(_messages.MESSAGE.destRequestTimeout);
    }

    _onError(err) {
        if (this._isSocketHangUpErr(err)) this.emit('socketHangUp');else if (requestAgent.shouldRegressHttps(err, this.opts)) {
            requestAgent.regressHttps(this.opts);
            this._send();
        } else if (this._isTunnelingErr(err)) {
            if (TUNNELING_AUTHORIZE_ERR_RE.test(err.message)) this._fatalError(_messages.MESSAGE.cantAuthorizeToProxy, this.opts.proxy.host);else this._fatalError(_messages.MESSAGE.cantEstablishTunnelingConnection, this.opts.proxy.host);
        } else if (this._isDNSErr(err)) {
            if (!this.isHttps && this.opts.proxy) this._fatalError(_messages.MESSAGE.cantEstablishProxyConnection, this.opts.proxy.host);else this._fatalError(_messages.MESSAGE.cantResolveUrl);
        } else this.emit('error');
    }
}

exports.default = DestinationRequest; // NOTE: Exposed for testing purposes.

DestinationRequest.TIMEOUT = 25 * 1000;
DestinationRequest.XHR_TIMEOUT = 2 * 60 * 1000;
module.exports = exports['default'];