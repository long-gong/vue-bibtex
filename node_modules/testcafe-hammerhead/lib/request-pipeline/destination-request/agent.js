'use strict';

exports.__esModule = true;
exports.assign = assign;
exports.shouldRegressHttps = shouldRegressHttps;
exports.regressHttps = regressHttps;
exports.resetKeepAliveConnections = resetKeepAliveConnections;

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _lruCache = require('lru-cache');

var _lruCache2 = _interopRequireDefault(_lruCache);

var _tunnelAgent = require('tunnel-agent');

var _tunnelAgent2 = _interopRequireDefault(_tunnelAgent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Const
const SSL3_HOST_CACHE_SIZE = 1000;

const TYPE = {
    SSL3: 'SSL3',
    TLS: 'TLS',
    HTTP: 'HTTP'
};

// Static
const ssl3HostCache = new _lruCache2.default({ max: SSL3_HOST_CACHE_SIZE });

const agents = {
    [TYPE.SSL3]: {
        instance: null,
        Ctor: _https2.default.Agent,
        secureProtocol: 'SSLv3_method'
    },

    [TYPE.TLS]: {
        instance: null,
        Ctor: _https2.default.Agent
    },

    [TYPE.HTTP]: {
        instance: null,
        Ctor: _http2.default.Agent
    }
};

// Utils
function getAgent(type) {
    const agent = agents[type];

    if (!agent.instance) {
        agent.instance = new agent.Ctor({
            keepAlive: true,
            secureProtocol: agent.secureProtocol
        });
    }

    return agent.instance;
}

function isSSLProtocolErr(err) {
    return err.message && err.message.includes('SSL routines');
}

// API
function assign(reqOpts) {
    const proxy = reqOpts.proxy;

    if (proxy && reqOpts.protocol === 'https:') {
        reqOpts.agent = _tunnelAgent2.default.httpsOverHttp({ proxy });

        return;
    }

    let type = void 0;

    if (reqOpts.protocol === 'http:') type = TYPE.HTTP;else if (ssl3HostCache.get(reqOpts.host)) type = TYPE.SSL3;else type = TYPE.TLS;

    reqOpts.agent = getAgent(type);
}

function shouldRegressHttps(reqErr, reqOpts) {
    return reqOpts.agent === agents[TYPE.TLS] && isSSLProtocolErr(reqErr);
}

function regressHttps(reqOpts) {
    ssl3HostCache.set(reqOpts.host, true);
    reqOpts.agent = getAgent(TYPE.SSL3);
}

// NOTE: Since our agents are keep-alive, we need to manually reset connections when we
// switch between servers in tests.
function resetKeepAliveConnections() {
    Object.keys(agents).forEach(type => {
        const agent = agents[type];

        if (agent.instance) agent.instance.destroy();

        agent.instance = null;
    });
}