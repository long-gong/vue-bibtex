'use strict';

exports.__esModule = true;
exports.run = run;

var _destinationRequest = require('./destination-request');

var _destinationRequest2 = _interopRequireDefault(_destinationRequest);

var _fileRequest = require('./file-request');

var _fileRequest2 = _interopRequireDefault(_fileRequest);

var _context = require('./context');

var _context2 = _interopRequireDefault(_context);

var _headerTransforms = require('./header-transforms');

var headerTransforms = _interopRequireWildcard(_headerTransforms);

var _resources = require('../processing/resources');

var _messages = require('../messages');

var _connectionResetGuard = require('./connection-reset-guard');

var _connectionResetGuard2 = _interopRequireDefault(_connectionResetGuard);

var _sameOriginCheckFailedStatusCode = require('./xhr/same-origin-check-failed-status-code');

var _sameOriginCheckFailedStatusCode2 = _interopRequireDefault(_sameOriginCheckFailedStatusCode);

var _http = require('../utils/http');

var _upload = require('../upload');

var _websocket = require('./websocket');

var _stream = require('stream');

var _specialPage = require('./special-page');

var _specialPage2 = _interopRequireDefault(_specialPage);

var _matchUrlWildcard = require('match-url-wildcard');

var _matchUrlWildcard2 = _interopRequireDefault(_matchUrlWildcard);

var _info = require('../session/events/info');

var requestEventInfo = _interopRequireWildcard(_info);

var _names = require('../session/events/names');

var _names2 = _interopRequireDefault(_names);

var _responseEvent = require('../session/events/response-event');

var _responseEvent2 = _interopRequireDefault(_responseEvent);

var _requestEvent = require('../session/events/request-event');

var _requestEvent2 = _interopRequireDefault(_requestEvent);

var _configureResponseEvent = require('../session/events/configure-response-event');

var _configureResponseEvent2 = _interopRequireDefault(_configureResponseEvent);

var _configureResponseEventOptions = require('../session/events/configure-response-event-options');

var _configureResponseEventOptions2 = _interopRequireDefault(_configureResponseEventOptions);

var _promisifyStream = require('../utils/promisify-stream');

var _promisifyStream2 = _interopRequireDefault(_promisifyStream);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const EVENT_SOURCE_REQUEST_TIMEOUT = 60 * 60 * 1000;

// Stages
const stages = {
    0: function handleSocketError(ctx, next) {
        // NOTE: In some case on MacOS, browser reset connection with server and we need to catch this exception.
        if (ctx.isWebSocket) {
            ctx.res.on('error', e => {
                if (e.code === 'ECONNRESET' && !ctx.mock) {
                    if (ctx.destRes) ctx.destRes.destroy();else ctx.isBrowserConnectionReset = true;
                } else throw e;
            });
        }

        next();
    },

    1: (() => {
        var _ref = _asyncToGenerator(function* (ctx, next) {
            if (ctx.isPage && !ctx.isIframe && !ctx.isHtmlImport) ctx.session.onPageRequest(ctx);

            ctx.reqBody = yield (0, _http.fetchBody)(ctx.req);

            next();
        });

        function fetchProxyRequestBody(_x, _x2) {
            return _ref.apply(this, arguments);
        }

        return fetchProxyRequestBody;
    })(),

    2: function sendDestinationRequest(ctx, next) {
        if (ctx.isSpecialPage) {
            ctx.destRes = (0, _specialPage2.default)();
            next();
        } else {
            ctx.reqOpts = createReqOpts(ctx);

            if (ctx.session.hasRequestEventListeners()) {
                const requestInfo = requestEventInfo.createRequestInfo(ctx, ctx.reqOpts);

                ctx.requestFilterRules = ctx.session.getRequestFilterRules(requestInfo);
                ctx.requestFilterRules.forEach(rule => {
                    callOnRequestEventCallback(ctx, rule, requestInfo);
                    setupMockIfNecessary(ctx, rule);
                });
            }

            if (ctx.mock) {
                mockResponse(ctx);
                next();
            } else sendRequest(ctx, next);
        }
    },

    3: function checkSameOriginPolicyCompliance(ctx, next) {
        ctx.buildContentInfo();

        if (!ctx.isKeepSameOriginPolicy()) {
            ctx.requestFilterRules.forEach(rule => {
                const configureResponseEvent = new _configureResponseEvent2.default(ctx, rule, _configureResponseEventOptions2.default.DEFAULT);

                ctx.session.callRequestEventCallback(_names2.default.onConfigureResponse, rule, configureResponseEvent);
                callOnResponseEventCallbackForFailedSameOriginCheck(ctx, rule, configureResponseEvent);
            });
            ctx.closeWithError(_sameOriginCheckFailedStatusCode2.default);

            return;
        }

        next();
    },

    4: function decideOnProcessingStrategy(ctx, next) {
        if (ctx.contentInfo.requireProcessing && ctx.destRes.statusCode === 204) ctx.destRes.statusCode = 200;

        if (ctx.isWebSocket) {
            (0, _websocket.respondOnWebSocket)(ctx);

            return;
        }
        // NOTE: Just pipe the content body to the browser if we don't need to process it.
        else if (!ctx.contentInfo.requireProcessing) {
                if (!ctx.isSpecialPage) {
                    ctx.requestFilterRules.forEach(rule => {
                        const configureResponseEvent = new _configureResponseEvent2.default(ctx, rule, _configureResponseEventOptions2.default.DEFAULT);

                        ctx.session.callRequestEventCallback(_names2.default.onConfigureResponse, rule, configureResponseEvent);

                        if (configureResponseEvent.opts.includeBody) callOnResponseEventCallbackWithCollectedBody(ctx, rule, configureResponseEvent.opts);else ctx.onResponseEventDataWithoutBody.push({ rule, opts: configureResponseEvent.opts });
                    });

                    sendResponseHeaders(ctx);

                    if (ctx.contentInfo.isNotModified) ctx.res.end();else ctx.destRes.pipe(ctx.res);

                    if (ctx.onResponseEventDataWithoutBody.length) {
                        ctx.res.on('finish', () => {
                            const responseInfo = requestEventInfo.createResponseInfo(ctx);

                            ctx.onResponseEventDataWithoutBody.forEach(item => {
                                const preparedResponseInfo = requestEventInfo.prepareEventData(responseInfo, item.opts);
                                const responseEvent = new _responseEvent2.default(item.rule, preparedResponseInfo);

                                ctx.session.callRequestEventCallback(_names2.default.onResponse, item.rule, responseEvent);
                            });
                        });
                    }

                    // NOTE: sets 60 minutes timeout for the "event source" requests instead of 2 minutes by default
                    if (ctx.dest.isEventSource) {
                        ctx.req.setTimeout(EVENT_SOURCE_REQUEST_TIMEOUT);
                        ctx.req.on('close', () => ctx.destRes.destroy());
                    }
                } else {
                    sendResponseHeaders(ctx);
                    ctx.res.end();
                }

                return;
            }

        next();
    },

    5: (() => {
        var _ref2 = _asyncToGenerator(function* (ctx, next) {
            ctx.destResBody = yield (0, _http.fetchBody)(ctx.destRes);

            if (ctx.requestFilterRules.length) ctx.saveNonProcessedDestResBody(ctx.destResBody);

            // NOTE: Sometimes the underlying socket emits an error event. But if we have a response body,
            // we can still process such requests. (B234324)
            if (ctx.hasDestReqErr && isDestResBodyMalformed(ctx)) {
                error(ctx, (0, _messages.getText)(_messages.MESSAGE.destConnectionTerminated, ctx.dest.url));

                return;
            }

            next();
        });

        function fetchContent(_x3, _x4) {
            return _ref2.apply(this, arguments);
        }

        return fetchContent;
    })(),

    6: (() => {
        var _ref3 = _asyncToGenerator(function* (ctx, next) {
            try {
                ctx.destResBody = yield (0, _resources.process)(ctx);
                next();
            } catch (err) {
                error(ctx, err);
            }
        });

        function processContent(_x5, _x6) {
            return _ref3.apply(this, arguments);
        }

        return processContent;
    })(),

    7: function sendProxyResponse(ctx) {
        const configureResponseEvents = ctx.requestFilterRules.map(rule => {
            const configureResponseEvent = new _configureResponseEvent2.default(ctx, rule, _configureResponseEventOptions2.default.DEFAULT);

            ctx.session.callRequestEventCallback(_names2.default.onConfigureResponse, rule, configureResponseEvent);
            return configureResponseEvent;
        });

        sendResponseHeaders(ctx);

        (0, _connectionResetGuard2.default)(() => {
            ctx.res.write(ctx.destResBody);
            ctx.res.end(() => {
                configureResponseEvents.forEach(configureResponseEvent => callResponseEventCallbackForProcessedRequest(ctx, configureResponseEvent));
            });
        });
    }
};

// Utils
function createReqOpts(ctx) {
    const bodyWithUploads = (0, _upload.inject)(ctx.req.headers['content-type'], ctx.reqBody);

    // NOTE: First, we should rewrite the request body, because the 'content-length' header will be built based on it.
    if (bodyWithUploads) ctx.reqBody = bodyWithUploads;

    // NOTE: All headers, including 'content-length', are built here.
    const headers = headerTransforms.forRequest(ctx);
    const proxy = ctx.session.externalProxySettings;
    const options = {
        url: ctx.dest.url,
        protocol: ctx.dest.protocol,
        hostname: ctx.dest.hostname,
        host: ctx.dest.host,
        port: ctx.dest.port,
        path: ctx.dest.partAfterHost,
        method: ctx.req.method,
        credentials: ctx.session.getAuthCredentials(),
        body: ctx.reqBody,
        isXhr: ctx.isXhr,
        rawHeaders: ctx.req.rawHeaders,

        headers
    };

    if (proxy && !(0, _matchUrlWildcard2.default)(ctx.dest.url, proxy.bypassRules)) {
        options.proxy = proxy;

        if (ctx.dest.protocol === 'http:') {
            options.path = options.protocol + '//' + options.host + options.path;
            options.host = proxy.host;
            options.hostname = proxy.hostname;
            options.port = proxy.port;

            if (proxy.authHeader) headers['proxy-authorization'] = proxy.authHeader;
        }
    }

    return options;
}

function sendResponseHeaders(ctx) {
    const headers = headerTransforms.forResponse(ctx);

    ctx.res.writeHead(ctx.destRes.statusCode, headers);
    ctx.res.addTrailers(ctx.destRes.trailers);
}

function error(ctx, err) {
    if (ctx.isPage && !ctx.isIframe) ctx.session.handlePageError(ctx, err);else if (ctx.isFetch || ctx.isXhr) ctx.req.destroy();else ctx.closeWithError(500, err.toString());
}

function isDestResBodyMalformed(ctx) {
    return !ctx.destResBody || ctx.destResBody.length !== ctx.destRes.headers['content-length'];
}

function callResponseEventCallbackForProcessedRequest(ctx, configureResponseEvent) {
    const responseInfo = requestEventInfo.createResponseInfo(ctx);
    const preparedResponseInfo = requestEventInfo.prepareEventData(responseInfo, configureResponseEvent.opts);
    const responseEvent = new _responseEvent2.default(configureResponseEvent._requestFilterRule, preparedResponseInfo);

    ctx.session.callRequestEventCallback(_names2.default.onResponse, configureResponseEvent._requestFilterRule, responseEvent);
}

function callOnRequestEventCallback(ctx, rule, reqInfo) {
    const requestEvent = new _requestEvent2.default(ctx, rule, reqInfo);

    ctx.session.callRequestEventCallback(_names2.default.onRequest, rule, requestEvent);
}

function callOnResponseEventCallbackWithCollectedBody(ctx, rule, configureOpts) {
    const destResBodyCollectorStream = new _stream.PassThrough();
    const promisifiedDestResBodyCollectorStream = (0, _promisifyStream2.default)(destResBodyCollectorStream);

    promisifiedDestResBodyCollectorStream.then(data => {
        ctx.saveNonProcessedDestResBody(data);

        const responseInfo = requestEventInfo.createResponseInfo(ctx);
        const preparedResponseInfo = requestEventInfo.prepareEventData(responseInfo, configureOpts);
        const responseEvent = new _responseEvent2.default(rule, preparedResponseInfo);

        ctx.session.callRequestEventCallback(_names2.default.onResponse, rule, responseEvent);
    });

    ctx.destRes.pipe(destResBodyCollectorStream);
}

function callOnResponseEventCallbackForFailedSameOriginCheck(ctx, rule, configureOpts) {
    const responseInfo = requestEventInfo.createResponseInfo(ctx);

    responseInfo.statusCode = _sameOriginCheckFailedStatusCode2.default;

    const preparedResponseInfo = requestEventInfo.prepareEventData(responseInfo, configureOpts);
    const responseEvent = new _responseEvent2.default(rule, preparedResponseInfo);

    ctx.session.callRequestEventCallback(_names2.default.onResponse, rule, responseEvent);
}

function mockResponse(ctx) {
    ctx.mock.setRequestOptions(ctx.reqOpts);
    ctx.destRes = ctx.mock.getResponse();
}

function setupMockIfNecessary(ctx, rule) {
    const mock = ctx.session.getMock(rule);

    if (mock && !ctx.mock) ctx.mock = mock;
}

function sendRequest(ctx, next) {
    const req = ctx.isFileProtocol ? new _fileRequest2.default(ctx.reqOpts) : new _destinationRequest2.default(ctx.reqOpts);

    req.on('response', res => {
        if (ctx.isBrowserConnectionReset) {
            res.destroy();

            return;
        }

        ctx.destRes = res;
        next();
    });

    req.on('error', () => {
        ctx.hasDestReqErr = true;
    });

    req.on('fatalError', err => error(ctx, err));

    req.on('socketHangUp', () => ctx.req.socket.end());
}

// API
function run(req, res, serverInfo, openSessions) {
    const ctx = new _context2.default(req, res, serverInfo);

    if (ctx.dispatch(openSessions)) {
        let stageIdx = 0;
        const next = () => stages[++stageIdx](ctx, next);

        stages[0](ctx, next);
    } else (0, _http.respond404)(res);
}