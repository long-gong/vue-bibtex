'use strict';

exports.__esModule = true;

var _mustache = require('mustache');

var _mustache2 = _interopRequireDefault(_mustache);

var _readFileRelative = require('read-file-relative');

var _events = require('events');

var _url = require('url');

var _cookies = require('./cookies');

var _cookies2 = _interopRequireDefault(_cookies);

var _storage = require('../upload/storage');

var _storage2 = _interopRequireDefault(_storage);

var _command = require('./command');

var _command2 = _interopRequireDefault(_command);

var _generateUniqueId = require('../utils/generate-unique-id');

var _generateUniqueId2 = _interopRequireDefault(_generateUniqueId);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const TASK_TEMPLATE = (0, _readFileRelative.readSync)('../client/task.js.mustache');

class Session extends _events.EventEmitter {
    constructor(uploadsRoot) {
        super();

        this.uploadStorage = new _storage2.default(uploadsRoot);

        this.id = (0, _generateUniqueId2.default)();
        this.cookies = new _cookies2.default();
        this.proxy = null;
        this.externalProxySettings = null;
        this.pageLoadCount = 0;

        this.requireStateSwitch = false;
        this.pendingStateSnapshot = null;

        this.injectable = {
            scripts: ['/hammerhead.js'],
            styles: []
        };

        this.requestEventListeners = new Map();
        this.mocks = new Map();
    }

    // State
    getStateSnapshot() {
        return {
            cookies: this.cookies.serializeJar(),
            storages: null
        };
    }

    useStateSnapshot(snapshot) {
        // NOTE: we don't perform state switch immediately, since there might be
        // pending requests from current page. Therefore, we perform switch in
        // onPageRequest handler when new page is requested.
        this.requireStateSwitch = true;
        this.pendingStateSnapshot = snapshot || {
            cookies: null,
            storages: {
                localStorage: '[[],[]]',
                sessionStorage: '[[],[]]'
            }
        };
    }

    handleServiceMessage(msg, serverInfo) {
        var _this = this;

        return _asyncToGenerator(function* () {
            if (_this[msg.cmd]) return yield _this[msg.cmd](msg, serverInfo);

            throw new Error('Malformed service message or message handler is not implemented');
        })();
    }

    _fillTaskScriptTemplate({ serverInfo, isFirstPageLoad, referer, cookie, iframeTaskScriptTemplate, payloadScript }) {
        referer = referer || '{{{referer}}}';
        cookie = cookie || '{{{cookie}}}';
        iframeTaskScriptTemplate = iframeTaskScriptTemplate || '{{{iframeTaskScriptTemplate}}}';

        const domain = serverInfo.domain,
              crossDomainPort = serverInfo.crossDomainPort;


        return _mustache2.default.render(TASK_TEMPLATE, {
            sessionId: this.id,
            serviceMsgUrl: domain + '/messaging',
            forceProxySrcForImage: this.hasRequestEventListeners(),
            crossDomainPort,
            isFirstPageLoad,
            referer,
            cookie,
            iframeTaskScriptTemplate,
            payloadScript
        });
    }

    getIframeTaskScriptTemplate(serverInfo) {
        const taskScriptTemplate = this._fillTaskScriptTemplate({
            serverInfo,
            isFirstPageLoad: false,
            referer: null,
            cookie: null,
            iframeTaskScriptTemplate: null,
            payloadScript: this._getIframePayloadScript(true)
        });

        return JSON.stringify(taskScriptTemplate);
    }

    getTaskScript({ referer, cookieUrl, serverInfo, isIframe, withPayload }) {
        const cookies = JSON.stringify(this.cookies.getClientString(cookieUrl));
        let payloadScript = '';

        if (withPayload) payloadScript = isIframe ? this._getIframePayloadScript() : this._getPayloadScript();

        const taskScript = this._fillTaskScriptTemplate({
            serverInfo,
            isFirstPageLoad: this.pageLoadCount === 0,
            referer,
            cookie: cookies,
            iframeTaskScriptTemplate: this.getIframeTaskScriptTemplate(serverInfo),
            payloadScript
        });

        this.pageLoadCount++;

        return taskScript;
    }

    setExternalProxySettings(proxySettings) {
        if (typeof proxySettings === 'string') proxySettings = { url: proxySettings };

        var _ref = proxySettings || {};

        const url = _ref.url,
              bypassRules = _ref.bypassRules;

        const parsedUrl = typeof url === 'string' ? (0, _url.parse)('http://' + url) : null;
        let settings = null;

        if (parsedUrl && parsedUrl.host) {
            settings = {
                host: parsedUrl.host,
                hostname: parsedUrl.hostname
            };

            if (bypassRules) settings.bypassRules = bypassRules;

            if (parsedUrl.port) settings.port = parsedUrl.port;

            if (parsedUrl.auth) {
                settings.proxyAuth = parsedUrl.auth;
                settings.authHeader = 'Basic ' + Buffer.from(parsedUrl.auth).toString('base64');
            }
        }

        this.externalProxySettings = settings;
    }

    onPageRequest(ctx) {
        if (this.requireStateSwitch) {
            this.cookies.setJar(this.pendingStateSnapshot.cookies);
            ctx.restoringStorages = this.pendingStateSnapshot.storages;
            this.requireStateSwitch = false;
            this.pendingStateSnapshot = null;
        }
    }

    // Request hooks
    hasRequestEventListeners() {
        return !!this.requestEventListeners.size;
    }

    addRequestEventListeners(requestFilterRule, eventListeners) {
        this.requestEventListeners.set(requestFilterRule, eventListeners);
    }

    removeRequestEventListeners(requestFilterRule) {
        this.requestEventListeners.delete(requestFilterRule);
    }

    getRequestFilterRules(requestInfo) {
        const rulesArray = Array.from(this.requestEventListeners.keys());

        return rulesArray.filter(rule => rule.match(requestInfo));
    }

    callRequestEventCallback(eventName, requestFilterRule, eventData) {
        const eventListeners = this.requestEventListeners.get(requestFilterRule);
        const targetRequestEventCallback = eventListeners[eventName];

        if (typeof targetRequestEventCallback === 'function') targetRequestEventCallback(eventData);
    }

    setMock(requestFilterRule, mock) {
        this.mocks.set(requestFilterRule, mock);
    }

    getMock(requestFilterRule) {
        return this.mocks.get(requestFilterRule);
    }

    _getIframePayloadScript() /* iframeWithoutSrc */{
        throw new Error('Not implemented');
    }

    _getPayloadScript() {
        throw new Error('Not implemented');
    }

    handleFileDownload() /* ctx */{
        throw new Error('Not implemented');
    }

    handlePageError() /* ctx, err */{
        throw new Error('Not implemented');
    }

    getAuthCredentials() {
        throw new Error('Not implemented');
    }

    // Service message handlers
    [_command2.default.uploadFiles](msg) {
        var _this2 = this;

        return _asyncToGenerator(function* () {
            return yield _this2.uploadStorage.store(msg.fileNames, msg.data);
        })();
    }

    [_command2.default.getUploadedFiles](msg) {
        var _this3 = this;

        return _asyncToGenerator(function* () {
            return yield _this3.uploadStorage.get(msg.filePaths);
        })();
    }
}
exports.default = Session;
module.exports = exports['default'];