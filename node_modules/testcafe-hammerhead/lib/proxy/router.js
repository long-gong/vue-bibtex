'use strict';

exports.__esModule = true;

var _cryptoMd = require('crypto-md5');

var _cryptoMd2 = _interopRequireDefault(_cryptoMd);

var _url = require('../utils/url');

var _http = require('../utils/http');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Const
const PARAM_RE = /^{(\S+)}$/;

// Static
function buildRouteParamsMap(routeMatch, paramNames) {
    return paramNames.reduce((params, paramName, i) => {
        params[paramName] = routeMatch[i + 1];
        return params;
    }, {});
}

// Router
class Router {
    constructor(options = {}) {
        this.options = options;
        this.routes = {};
        this.routesWithParams = [];
    }

    _registerRoute(route, method, handler) {
        const tokens = route.split('/');
        const isRouteWithParams = tokens.some(token => PARAM_RE.test(token));

        if (isRouteWithParams) this._registerRouteWithParams(tokens, method, handler);else {
            const isStatic = typeof handler !== 'function';

            if (isStatic) {
                this._processStaticContent(handler);

                handler.etag = (0, _cryptoMd2.default)(handler.content);
            }

            this.routes[`${method} ${route}`] = {
                handler: handler,
                isStatic: isStatic
            };
        }
    }

    _registerRouteWithParams(tokens, method, handler) {
        const paramNames = [];
        const reParts = tokens.map(token => {
            const paramMatch = token.match(PARAM_RE);

            if (paramMatch) {
                paramNames.push(paramMatch[1]);
                return '(\\S+?)';
            }

            return token;
        });

        this.routesWithParams.push({
            paramNames: paramNames,

            re: new RegExp(`^${method} ${reParts.join('/')}$`),
            handler: handler
        });
    }

    _route(req, res, serverInfo) {
        const routerQuery = `${req.method} ${(0, _url.getPathname)(req.url)}`;
        let route = this.routes[routerQuery];

        if (route) {
            if (route.isStatic) (0, _http.respondStatic)(req, res, route.handler, this.options.staticContentCaching);else route.handler(req, res, serverInfo);

            return true;
        }

        for (let i = 0; i < this.routesWithParams.length; i++) {
            route = this.routesWithParams[i];

            const routeMatch = routerQuery.match(route.re);

            if (routeMatch) {
                const params = buildRouteParamsMap(routeMatch, route.paramNames);

                route.handler(req, res, serverInfo, params);
                return true;
            }
        }

        return false;
    }

    _processStaticContent() {
        throw new Error('Not implemented');
    }

    // API
    GET(route, handler) {
        this._registerRoute(route, 'GET', handler);
    }

    POST(route, handler) {
        this._registerRoute(route, 'POST', handler);
    }
}
exports.default = Router;
module.exports = exports['default'];