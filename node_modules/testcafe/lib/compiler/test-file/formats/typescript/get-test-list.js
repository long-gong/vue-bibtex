'use strict';

exports.__esModule = true;
exports.getTypeScriptTestListFromCode = exports.getTypeScriptTestList = undefined;

var _typescript = require('typescript');

var _typescript2 = _interopRequireDefault(_typescript);

var _lodash = require('lodash');

var _compiler = require('./compiler');

var _compiler2 = _interopRequireDefault(_compiler);

var _testFileParserBase = require('../../test-file-parser-base');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function replaceComments(code) {
    return code.replace(/\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, match => {
        const lastSymbol = match.indexOf('\n') > -1 ? '\n' : ' ';

        return (0, _lodash.repeat)(' ', match.length + lastSymbol);
    });
}

class TypeScriptTestFileParser extends _testFileParserBase.TestFileParserBase {
    constructor() {
        super(_typescript2.default.SyntaxKind);
    }

    getComputedNameString({ pos, end }) {
        const templatePos = this.getLocationByOffsets(pos, end);

        return _testFileParserBase.TestFileParserBase.formatComputedName(templatePos.loc.start.line);
    }

    getTokenType(token) {
        return token.kind;
    }

    getCalleeToken(token) {
        return token.expression;
    }

    getMemberFnName(token) {
        return token.expression.name.text;
    }

    getKeyValue(prop) {
        const name = prop.name,
              initializer = prop.initializer;


        return {
            key: name.text,
            value: this.getStringValue(initializer)
        };
    }

    getFixedStartOffset(start) {
        let fixedStartOffset = start;

        while (/\s/.test(this.codeWithoutComments[fixedStartOffset])) ++fixedStartOffset;

        return fixedStartOffset;
    }

    getLocationByOffsets(start, end) {
        const fixedStart = this.getFixedStartOffset(start);
        const codeArr = this.codeArr;
        const loc = { start: null, end: null };

        let line = codeArr[0];
        let startTmp = fixedStart;
        let endTmp = end;

        for (let lineNumber = 1; lineNumber <= codeArr.length; ++lineNumber, line = codeArr[lineNumber - 1]) {
            startTmp -= line.length + 1;
            endTmp -= line.length + 1;

            if (startTmp < 0 && !loc.start) loc.start = { line: lineNumber, column: line.length + startTmp + 1 };

            if (endTmp <= 0 || lineNumber === codeArr.length - 1) {
                loc.end = { line: lineNumber, column: line.length + endTmp + 1 };

                break;
            }
        }

        return { loc, start: fixedStart, end };
    }

    getRValue(token) {
        return token.declarationList.declarations[0].initializer;
    }

    getStringValue(token) {
        const stringTypes = [this.tokenType.StringLiteral, this.tokenType.TemplateExpression];

        if (stringTypes.indexOf(token.kind) > -1 || token.text && token.kind !== this.tokenType.NumericLiteral) return this.formatFnArg(token);

        return null;
    }

    isAsyncFn(token) {
        const isGeneratorFn = !!token.asteriskToken;
        const isAsyncFn = token.modifiers && token.modifiers.some(modifier => modifier.kind === this.tokenType.AsyncKeyword);

        return isGeneratorFn || isAsyncFn;
    }

    getFunctionBody(token) {
        return token.body.statements;
    }

    formatFnData(name, value, token, meta = [{}]) {
        const loc = this.getLocationByOffsets(token.pos, token.end);

        return {
            fnName: name,
            value: value,
            loc: loc.loc,
            start: loc.start,
            end: loc.end,
            meta: (0, _lodash.merge)({}, ...meta)
        };
    }

    analyzeMemberExp(token) {
        let exp = token;
        const tokenType = this.tokenType;
        const callStack = [exp];

        while (exp.kind !== this.tokenType.Identifier) {
            exp = exp.expression || exp.tag;

            callStack.push(exp);
        }

        const meta = this.getMetaInfo(callStack.slice());

        if (exp && this.isApiFn(exp.text)) {
            let parentExp = callStack.pop();

            while (parentExp) {
                if (parentExp.kind === tokenType.CallExpression && parentExp.expression) {
                    const calleeType = parentExp.expression.kind;
                    const calleeMemberFn = calleeType === tokenType.PropertyAccessExpression && parentExp.expression.name.text;

                    if (this.checkExpDefineTargetName(calleeType, calleeMemberFn)) return this.formatFnData(exp.text, this.formatFnArg(parentExp.arguments[0]), token, meta);
                }

                if (parentExp.kind === tokenType.TaggedTemplateExpression && parentExp.tag) {
                    const tagType = parentExp.tag.kind;
                    const tagMemberFn = tagType === tokenType.PropertyAccessExpression && parentExp.tag.name.text;

                    if (this.checkExpDefineTargetName(tagType, tagMemberFn)) return this.formatFnData(exp.text, this.formatFnArg(parentExp), token, meta);
                }

                parentExp = callStack.pop();
            }
        }

        return null;
    }

    formatFnArg(arg) {
        if (arg.templateSpans) return this.getComputedNameString({ pos: arg.pos, end: arg.end });

        if (arg.head) return this.getComputedNameString({ pos: arg.template.pos, end: arg.template.end });

        if (arg.template) return arg.template.text || this.getComputedNameString({ pos: arg.template.pos, end: arg.template.end });

        if (arg.kind === this.tokenType.Identifier) return this.getComputedNameString({ pos: arg.pos, end: arg.end });

        if (arg.text && arg.kind !== this.tokenType.NumericLiteral) return arg.text;

        if (arg.kind === this.tokenType.TypeAssertionExpression) return this.formatFnArg(arg.expression);

        return null;
    }

    getFnCall(token) {
        if (this.isApiFn(token.expression.text)) return this.formatFnData(token.expression.text, this.formatFnArg(token.arguments[0]), token);

        return null;
    }

    getTaggedTemplateExp(token) {
        if (this.isApiFn(token.tag.text)) return this.formatFnData(token.tag.text, this.formatFnArg(token), token);

        return null;
    }

    analyzeFnCall(token) {
        const tokenType = this.tokenType;

        if (token.kind === tokenType.PropertyAccessExpression) return this.analyzeMemberExp(token);

        if (token.kind === tokenType.CallExpression) {
            const expKind = token.expression.kind;

            if (expKind === tokenType.PropertyAccessExpression || expKind === tokenType.CallExpression) return this.analyzeMemberExp(token);

            if (expKind === tokenType.ParenthesizedExpression) return this.analyzeFnCall(token.expression.expression);

            return this.getFnCall(token);
        }

        if (token.kind === tokenType.FunctionExpression || token.kind === tokenType.ArrowFunction) return this.collectTestCafeCalls(this.getFunctionBody(token));

        if (token.kind === tokenType.TaggedTemplateExpression) {
            if (token.tag.kind === tokenType.PropertyAccessExpression || token.tag.kind === tokenType.CallExpression) return this.analyzeMemberExp(token);

            return this.getTaggedTemplateExp(token);
        }

        return null;
    }

    parse(code) {
        //NOTE: TypeScript calculates start position of a token incorrectly
        //It doesn't consider spaces and comments between the last token and the current token.
        //So we replace comments with space symbols to calculate fixed position.
        //We just increment position until we meet non whitespace characters
        this.codeArr = code.split('\n');
        this.codeWithoutComments = replaceComments(code);

        const sourceFile = _typescript2.default.createSourceFile('', code, _compiler2.default._getTypescriptOptions(), true);

        return this.analyze(sourceFile.statements);
    }
}

const parser = new TypeScriptTestFileParser();

const getTypeScriptTestList = exports.getTypeScriptTestList = parser.getTestList.bind(parser);
const getTypeScriptTestListFromCode = exports.getTypeScriptTestListFromCode = parser.getTestListFromCode.bind(parser);
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9jb21waWxlci90ZXN0LWZpbGUvZm9ybWF0cy90eXBlc2NyaXB0L2dldC10ZXN0LWxpc3QuanMiXSwibmFtZXMiOlsicmVwbGFjZUNvbW1lbnRzIiwiY29kZSIsInJlcGxhY2UiLCJtYXRjaCIsImxhc3RTeW1ib2wiLCJpbmRleE9mIiwibGVuZ3RoIiwiVHlwZVNjcmlwdFRlc3RGaWxlUGFyc2VyIiwiVGVzdEZpbGVQYXJzZXJCYXNlIiwiY29uc3RydWN0b3IiLCJ0cyIsIlN5bnRheEtpbmQiLCJnZXRDb21wdXRlZE5hbWVTdHJpbmciLCJwb3MiLCJlbmQiLCJ0ZW1wbGF0ZVBvcyIsImdldExvY2F0aW9uQnlPZmZzZXRzIiwiZm9ybWF0Q29tcHV0ZWROYW1lIiwibG9jIiwic3RhcnQiLCJsaW5lIiwiZ2V0VG9rZW5UeXBlIiwidG9rZW4iLCJraW5kIiwiZ2V0Q2FsbGVlVG9rZW4iLCJleHByZXNzaW9uIiwiZ2V0TWVtYmVyRm5OYW1lIiwibmFtZSIsInRleHQiLCJnZXRLZXlWYWx1ZSIsInByb3AiLCJpbml0aWFsaXplciIsImtleSIsInZhbHVlIiwiZ2V0U3RyaW5nVmFsdWUiLCJnZXRGaXhlZFN0YXJ0T2Zmc2V0IiwiZml4ZWRTdGFydE9mZnNldCIsInRlc3QiLCJjb2RlV2l0aG91dENvbW1lbnRzIiwiZml4ZWRTdGFydCIsImNvZGVBcnIiLCJzdGFydFRtcCIsImVuZFRtcCIsImxpbmVOdW1iZXIiLCJjb2x1bW4iLCJnZXRSVmFsdWUiLCJkZWNsYXJhdGlvbkxpc3QiLCJkZWNsYXJhdGlvbnMiLCJzdHJpbmdUeXBlcyIsInRva2VuVHlwZSIsIlN0cmluZ0xpdGVyYWwiLCJUZW1wbGF0ZUV4cHJlc3Npb24iLCJOdW1lcmljTGl0ZXJhbCIsImZvcm1hdEZuQXJnIiwiaXNBc3luY0ZuIiwiaXNHZW5lcmF0b3JGbiIsImFzdGVyaXNrVG9rZW4iLCJtb2RpZmllcnMiLCJzb21lIiwibW9kaWZpZXIiLCJBc3luY0tleXdvcmQiLCJnZXRGdW5jdGlvbkJvZHkiLCJib2R5Iiwic3RhdGVtZW50cyIsImZvcm1hdEZuRGF0YSIsIm1ldGEiLCJmbk5hbWUiLCJhbmFseXplTWVtYmVyRXhwIiwiZXhwIiwiY2FsbFN0YWNrIiwiSWRlbnRpZmllciIsInRhZyIsInB1c2giLCJnZXRNZXRhSW5mbyIsInNsaWNlIiwiaXNBcGlGbiIsInBhcmVudEV4cCIsInBvcCIsIkNhbGxFeHByZXNzaW9uIiwiY2FsbGVlVHlwZSIsImNhbGxlZU1lbWJlckZuIiwiUHJvcGVydHlBY2Nlc3NFeHByZXNzaW9uIiwiY2hlY2tFeHBEZWZpbmVUYXJnZXROYW1lIiwiYXJndW1lbnRzIiwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uIiwidGFnVHlwZSIsInRhZ01lbWJlckZuIiwiYXJnIiwidGVtcGxhdGVTcGFucyIsImhlYWQiLCJ0ZW1wbGF0ZSIsIlR5cGVBc3NlcnRpb25FeHByZXNzaW9uIiwiZ2V0Rm5DYWxsIiwiZ2V0VGFnZ2VkVGVtcGxhdGVFeHAiLCJhbmFseXplRm5DYWxsIiwiZXhwS2luZCIsIlBhcmVudGhlc2l6ZWRFeHByZXNzaW9uIiwiRnVuY3Rpb25FeHByZXNzaW9uIiwiQXJyb3dGdW5jdGlvbiIsImNvbGxlY3RUZXN0Q2FmZUNhbGxzIiwicGFyc2UiLCJzcGxpdCIsInNvdXJjZUZpbGUiLCJjcmVhdGVTb3VyY2VGaWxlIiwiVHlwZVNjcmlwdFRlc3RGaWxlQ29tcGlsZXIiLCJfZ2V0VHlwZXNjcmlwdE9wdGlvbnMiLCJhbmFseXplIiwicGFyc2VyIiwiZ2V0VHlwZVNjcmlwdFRlc3RMaXN0IiwiZ2V0VGVzdExpc3QiLCJiaW5kIiwiZ2V0VHlwZVNjcmlwdFRlc3RMaXN0RnJvbUNvZGUiLCJnZXRUZXN0TGlzdEZyb21Db2RlIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBOzs7O0FBQ0E7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBLFNBQVNBLGVBQVQsQ0FBMEJDLElBQTFCLEVBQWdDO0FBQzVCLFdBQU9BLEtBQUtDLE9BQUwsQ0FBYSxzQ0FBYixFQUFx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QUFDQTtBQUNBLGFBQUt1QyxPQUFMLEdBQTJCdkMsS0FBS29HLEtBQUwsQ0FBVyxJQUFYLENBQTNCO0FBQ0EsYUFBSy9ELG1CQUFMLEdBQTJCdEMsZ0JBQWdCQyxJQUFoQixDQUEzQjs7QUFFQSxjQUFNcUcsYUFBYTVGLHFCQUFHNkYsZ0JBQUgsQ0FBb0IsRUFBcEIsRUFBd0J0RyxJQUF4QixFQUE4QnVHLG1CQUEyQkMscUJBQTNCLEVBQTlCLEVBQWtGLElBQWxGLENBQW5COztBQUVBLGVBQU8sS0FBS0MsT0FBTCxDQUFhSixXQUFXdkMsVUFBeEIsQ0FBUDtBQUNIO0FBaE9xRDs7QUFtTzFELE1BQU00QyxTQUFTLElBQUlwRyx3QkFBSixFQUFmOztBQUVPLE1BQU1xRyx3REFBZ0NELE9BQU9FLFdBQVAsQ0FBbUJDLElBQW5CLENBQXdCSCxNQUF4QixDQUF0QztBQUNBLE1BQU1JLHdFQUFnQ0osT0FBT0ssbUJBQVAsQ0FBMkJGLElBQTNCLENBQWdDSCxNQUFoQyxDQUF0QyIsImZpbGUiOiJjb21waWxlci90ZXN0LWZpbGUvZm9ybWF0cy90eXBlc2NyaXB0L2dldC10ZXN0LWxpc3QuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHMgZnJvbSAndHlwZXNjcmlwdCc7XG5pbXBvcnQgeyByZXBlYXQsIG1lcmdlIH0gZnJvbSAnbG9kYXNoJztcbmltcG9ydCBUeXBlU2NyaXB0VGVzdEZpbGVDb21waWxlciBmcm9tICcuL2NvbXBpbGVyJztcbmltcG9ydCB7IFRlc3RGaWxlUGFyc2VyQmFzZSB9IGZyb20gJy4uLy4uL3Rlc3QtZmlsZS1wYXJzZXItYmFzZSc7XG5cbmZ1bmN0aW9uIHJlcGxhY2VDb21tZW50cyAoY29kZSkge1xuICAgIHJldHVybiBjb2RlLnJlcGxhY2UoL1xcL1xcKltcXHNcXFNdKj9cXCpcXC98KFteXFxcXDpdfF4pXFwvXFwvLiokL2dtLCBtYXRjaCA9PiB7XG4gICAgICAgIGNvbnN0IGxhc3RTeW1ib2wgPSBtYXRjaC5pbmRleE9mKCdcXG4nKSA+IC0xID8gJ1xcbicgOiAnICc7XG5cbiAgICAgICAgcmV0dXJuIHJlcGVhdCgnICcsIG1hdGNoLmxlbmd0aCArIGxhc3RTeW1ib2wpO1xuICAgIH0pO1xufVxuXG5jbGFzcyBUeXBlU2NyaXB0VGVzdEZpbGVQYXJzZXIgZXh0ZW5kcyBUZXN0RmlsZVBhcnNlckJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgc3VwZXIodHMuU3ludGF4S2luZCk7XG4gICAgfVxuXG4gICAgZ2V0Q29tcHV0ZWROYW1lU3RyaW5nICh7IHBvcywgZW5kIH0pIHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVQb3MgPSB0aGlzLmdldExvY2F0aW9uQnlPZmZzZXRzKHBvcywgZW5kKTtcblxuICAgICAgICByZXR1cm4gVGVzdEZpbGVQYXJzZXJCYXNlLmZvcm1hdENvbXB1dGVkTmFtZSh0ZW1wbGF0ZVBvcy5sb2Muc3RhcnQubGluZSk7XG4gICAgfVxuXG4gICAgZ2V0VG9rZW5UeXBlICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4ua2luZDtcbiAgICB9XG5cbiAgICBnZXRDYWxsZWVUb2tlbiAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLmV4cHJlc3Npb247XG4gICAgfVxuXG4gICAgZ2V0TWVtYmVyRm5OYW1lICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4uZXhwcmVzc2lvbi5uYW1lLnRleHQ7XG4gICAgfVxuXG4gICAgZ2V0S2V5VmFsdWUgKHByb3ApIHtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBpbml0aWFsaXplciB9ID0gcHJvcDtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiAgIG5hbWUudGV4dCxcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLmdldFN0cmluZ1ZhbHVlKGluaXRpYWxpemVyKVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIGdldEZpeGVkU3RhcnRPZmZzZXQgKHN0YXJ0KSB7XG4gICAgICAgIGxldCBmaXhlZFN0YXJ0T2Zmc2V0ID0gc3RhcnQ7XG5cbiAgICAgICAgd2hpbGUgKC9cXHMvLnRlc3QodGhpcy5jb2RlV2l0aG91dENvbW1lbnRzW2ZpeGVkU3RhcnRPZmZzZXRdKSlcbiAgICAgICAgICAgICsrZml4ZWRTdGFydE9mZnNldDtcblxuICAgICAgICByZXR1cm4gZml4ZWRTdGFydE9mZnNldDtcbiAgICB9XG5cbiAgICBnZXRMb2NhdGlvbkJ5T2Zmc2V0cyAoc3RhcnQsIGVuZCkge1xuICAgICAgICBjb25zdCBmaXhlZFN0YXJ0ID0gdGhpcy5nZXRGaXhlZFN0YXJ0T2Zmc2V0KHN0YXJ0KTtcbiAgICAgICAgY29uc3QgY29kZUFyciAgICA9IHRoaXMuY29kZUFycjtcbiAgICAgICAgY29uc3QgbG9jICAgICAgICA9IHsgc3RhcnQ6IG51bGwsIGVuZDogbnVsbCB9O1xuXG4gICAgICAgIGxldCBsaW5lICAgICA9IGNvZGVBcnJbMF07XG4gICAgICAgIGxldCBzdGFydFRtcCA9IGZpeGVkU3RhcnQ7XG4gICAgICAgIGxldCBlbmRUbXAgICA9IGVuZDtcblxuICAgICAgICBmb3IgKGxldCBsaW5lTnVtYmVyID0gMTsgbGluZU51bWJlciA8PSBjb2RlQXJyLmxlbmd0aDsgKytsaW5lTnVtYmVyLCBsaW5lID0gY29kZUFycltsaW5lTnVtYmVyIC0gMV0pIHtcbiAgICAgICAgICAgIHN0YXJ0VG1wIC09IGxpbmUubGVuZ3RoICsgMTtcbiAgICAgICAgICAgIGVuZFRtcCAtPSBsaW5lLmxlbmd0aCArIDE7XG5cbiAgICAgICAgICAgIGlmIChzdGFydFRtcCA8IDAgJiYgIWxvYy5zdGFydClcbiAgICAgICAgICAgICAgICBsb2Muc3RhcnQgPSB7IGxpbmU6IGxpbmVOdW1iZXIsIGNvbHVtbjogbGluZS5sZW5ndGggKyBzdGFydFRtcCArIDEgfTtcblxuICAgICAgICAgICAgaWYgKGVuZFRtcCA8PSAwIHx8IGxpbmVOdW1iZXIgPT09IGNvZGVBcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGxvYy5lbmQgPSB7IGxpbmU6IGxpbmVOdW1iZXIsIGNvbHVtbjogbGluZS5sZW5ndGggKyBlbmRUbXAgKyAxIH07XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7IGxvYywgc3RhcnQ6IGZpeGVkU3RhcnQsIGVuZCB9O1xuICAgIH1cblxuICAgIGdldFJWYWx1ZSAodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIHRva2VuLmRlY2xhcmF0aW9uTGlzdC5kZWNsYXJhdGlvbnNbMF0uaW5pdGlhbGl6ZXI7XG4gICAgfVxuXG4gICAgZ2V0U3RyaW5nVmFsdWUgKHRva2VuKSB7XG4gICAgICAgIGNvbnN0IHN0cmluZ1R5cGVzID0gW3RoaXMudG9rZW5UeXBlLlN0cmluZ0xpdGVyYWwsIHRoaXMudG9rZW5UeXBlLlRlbXBsYXRlRXhwcmVzc2lvbl07XG5cbiAgICAgICAgaWYgKHN0cmluZ1R5cGVzLmluZGV4T2YodG9rZW4ua2luZCkgPiAtMSB8fCB0b2tlbi50ZXh0ICYmIHRva2VuLmtpbmQgIT09IHRoaXMudG9rZW5UeXBlLk51bWVyaWNMaXRlcmFsKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0Rm5BcmcodG9rZW4pO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlzQXN5bmNGbiAodG9rZW4pIHtcbiAgICAgICAgY29uc3QgaXNHZW5lcmF0b3JGbiA9ICEhdG9rZW4uYXN0ZXJpc2tUb2tlbjtcbiAgICAgICAgY29uc3QgaXNBc3luY0ZuICAgICA9IHRva2VuLm1vZGlmaWVycyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubW9kaWZpZXJzLnNvbWUobW9kaWZpZXIgPT4gbW9kaWZpZXIua2luZCA9PT0gdGhpcy50b2tlblR5cGUuQXN5bmNLZXl3b3JkKTtcblxuICAgICAgICByZXR1cm4gaXNHZW5lcmF0b3JGbiB8fCBpc0FzeW5jRm47XG4gICAgfVxuXG4gICAgZ2V0RnVuY3Rpb25Cb2R5ICh0b2tlbikge1xuICAgICAgICByZXR1cm4gdG9rZW4uYm9keS5zdGF0ZW1lbnRzO1xuICAgIH1cblxuICAgIGZvcm1hdEZuRGF0YSAobmFtZSwgdmFsdWUsIHRva2VuLCBtZXRhID0gW3t9XSkge1xuICAgICAgICBjb25zdCBsb2MgPSB0aGlzLmdldExvY2F0aW9uQnlPZmZzZXRzKHRva2VuLnBvcywgdG9rZW4uZW5kKTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm5OYW1lOiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6ICB2YWx1ZSxcbiAgICAgICAgICAgIGxvYzogICAgbG9jLmxvYyxcbiAgICAgICAgICAgIHN0YXJ0OiAgbG9jLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiAgICBsb2MuZW5kLFxuICAgICAgICAgICAgbWV0YTogICBtZXJnZSh7fSwgLi4ubWV0YSlcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhbmFseXplTWVtYmVyRXhwICh0b2tlbikge1xuICAgICAgICBsZXQgZXhwICAgICAgICAgPSB0b2tlbjtcbiAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy50b2tlblR5cGU7XG4gICAgICAgIGNvbnN0IGNhbGxTdGFjayA9IFtleHBdO1xuXG4gICAgICAgIHdoaWxlIChleHAua2luZCAhPT0gdGhpcy50b2tlblR5cGUuSWRlbnRpZmllcikge1xuICAgICAgICAgICAgZXhwID0gZXhwLmV4cHJlc3Npb24gfHwgZXhwLnRhZztcblxuICAgICAgICAgICAgY2FsbFN0YWNrLnB1c2goZXhwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG1ldGEgPSB0aGlzLmdldE1ldGFJbmZvKGNhbGxTdGFjay5zbGljZSgpKTtcblxuICAgICAgICBpZiAoZXhwICYmIHRoaXMuaXNBcGlGbihleHAudGV4dCkpIHtcbiAgICAgICAgICAgIGxldCBwYXJlbnRFeHAgPSBjYWxsU3RhY2sucG9wKCk7XG5cbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnRFeHApIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50RXhwLmtpbmQgPT09IHRva2VuVHlwZS5DYWxsRXhwcmVzc2lvbiAmJiBwYXJlbnRFeHAuZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWxsZWVUeXBlICAgICA9IHBhcmVudEV4cC5leHByZXNzaW9uLmtpbmQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxlZU1lbWJlckZuID0gY2FsbGVlVHlwZSA9PT0gdG9rZW5UeXBlLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudEV4cC5leHByZXNzaW9uLm5hbWUudGV4dDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0V4cERlZmluZVRhcmdldE5hbWUoY2FsbGVlVHlwZSwgY2FsbGVlTWVtYmVyRm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0Rm5EYXRhKGV4cC50ZXh0LCB0aGlzLmZvcm1hdEZuQXJnKHBhcmVudEV4cC5hcmd1bWVudHNbMF0pLCB0b2tlbiwgbWV0YSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHBhcmVudEV4cC5raW5kID09PSB0b2tlblR5cGUuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uICYmIHBhcmVudEV4cC50YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFnVHlwZSAgICAgPSBwYXJlbnRFeHAudGFnLmtpbmQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhZ01lbWJlckZuID0gdGFnVHlwZSA9PT0gdG9rZW5UeXBlLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiAmJiBwYXJlbnRFeHAudGFnLm5hbWUudGV4dDtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jaGVja0V4cERlZmluZVRhcmdldE5hbWUodGFnVHlwZSwgdGFnTWVtYmVyRm4pKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0Rm5EYXRhKGV4cC50ZXh0LCB0aGlzLmZvcm1hdEZuQXJnKHBhcmVudEV4cCksIHRva2VuLCBtZXRhKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBwYXJlbnRFeHAgPSBjYWxsU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBmb3JtYXRGbkFyZyAoYXJnKSB7XG4gICAgICAgIGlmIChhcmcudGVtcGxhdGVTcGFucylcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXB1dGVkTmFtZVN0cmluZyh7IHBvczogYXJnLnBvcywgZW5kOiBhcmcuZW5kIH0pO1xuXG4gICAgICAgIGlmIChhcmcuaGVhZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbXB1dGVkTmFtZVN0cmluZyh7IHBvczogYXJnLnRlbXBsYXRlLnBvcywgZW5kOiBhcmcudGVtcGxhdGUuZW5kIH0pO1xuXG4gICAgICAgIGlmIChhcmcudGVtcGxhdGUpXG4gICAgICAgICAgICByZXR1cm4gYXJnLnRlbXBsYXRlLnRleHQgfHwgdGhpcy5nZXRDb21wdXRlZE5hbWVTdHJpbmcoeyBwb3M6IGFyZy50ZW1wbGF0ZS5wb3MsIGVuZDogYXJnLnRlbXBsYXRlLmVuZCB9KTtcblxuICAgICAgICBpZiAoYXJnLmtpbmQgPT09IHRoaXMudG9rZW5UeXBlLklkZW50aWZpZXIpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wdXRlZE5hbWVTdHJpbmcoeyBwb3M6IGFyZy5wb3MsIGVuZDogYXJnLmVuZCB9KTtcblxuICAgICAgICBpZiAoYXJnLnRleHQgJiYgYXJnLmtpbmQgIT09IHRoaXMudG9rZW5UeXBlLk51bWVyaWNMaXRlcmFsKVxuICAgICAgICAgICAgcmV0dXJuIGFyZy50ZXh0O1xuXG4gICAgICAgIGlmIChhcmcua2luZCA9PT0gdGhpcy50b2tlblR5cGUuVHlwZUFzc2VydGlvbkV4cHJlc3Npb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRGbkFyZyhhcmcuZXhwcmVzc2lvbik7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgZ2V0Rm5DYWxsICh0b2tlbikge1xuICAgICAgICBpZiAodGhpcy5pc0FwaUZuKHRva2VuLmV4cHJlc3Npb24udGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRGbkRhdGEodG9rZW4uZXhwcmVzc2lvbi50ZXh0LCB0aGlzLmZvcm1hdEZuQXJnKHRva2VuLmFyZ3VtZW50c1swXSksIHRva2VuKTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBnZXRUYWdnZWRUZW1wbGF0ZUV4cCAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcGlGbih0b2tlbi50YWcudGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXRGbkRhdGEodG9rZW4udGFnLnRleHQsIHRoaXMuZm9ybWF0Rm5BcmcodG9rZW4pLCB0b2tlbik7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgYW5hbHl6ZUZuQ2FsbCAodG9rZW4pIHtcbiAgICAgICAgY29uc3QgdG9rZW5UeXBlID0gdGhpcy50b2tlblR5cGU7XG5cbiAgICAgICAgaWYgKHRva2VuLmtpbmQgPT09IHRva2VuVHlwZS5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hbmFseXplTWVtYmVyRXhwKHRva2VuKTtcblxuICAgICAgICBpZiAodG9rZW4ua2luZCA9PT0gdG9rZW5UeXBlLkNhbGxFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBjb25zdCBleHBLaW5kID0gdG9rZW4uZXhwcmVzc2lvbi5raW5kO1xuXG4gICAgICAgICAgICBpZiAoZXhwS2luZCA9PT0gdG9rZW5UeXBlLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbiB8fCBleHBLaW5kID09PSB0b2tlblR5cGUuQ2FsbEV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5hbHl6ZU1lbWJlckV4cCh0b2tlbik7XG5cbiAgICAgICAgICAgIGlmIChleHBLaW5kID09PSB0b2tlblR5cGUuUGFyZW50aGVzaXplZEV4cHJlc3Npb24pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYW5hbHl6ZUZuQ2FsbCh0b2tlbi5leHByZXNzaW9uLmV4cHJlc3Npb24pO1xuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGbkNhbGwodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRva2VuLmtpbmQgPT09IHRva2VuVHlwZS5GdW5jdGlvbkV4cHJlc3Npb24gfHwgdG9rZW4ua2luZCA9PT0gdG9rZW5UeXBlLkFycm93RnVuY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb2xsZWN0VGVzdENhZmVDYWxscyh0aGlzLmdldEZ1bmN0aW9uQm9keSh0b2tlbikpO1xuXG4gICAgICAgIGlmICh0b2tlbi5raW5kID09PSB0b2tlblR5cGUuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICBpZiAodG9rZW4udGFnLmtpbmQgPT09IHRva2VuVHlwZS5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb24gfHwgdG9rZW4udGFnLmtpbmQgPT09IHRva2VuVHlwZS5DYWxsRXhwcmVzc2lvbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hbmFseXplTWVtYmVyRXhwKHRva2VuKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VGFnZ2VkVGVtcGxhdGVFeHAodG9rZW4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcGFyc2UgKGNvZGUpIHtcbiAgICAgICAgLy9OT1RFOiBUeXBlU2NyaXB0IGNhbGN1bGF0ZXMgc3RhcnQgcG9zaXRpb24gb2YgYSB0b2tlbiBpbmNvcnJlY3RseVxuICAgICAgICAvL0l0IGRvZXNuJ3QgY29uc2lkZXIgc3BhY2VzIGFuZCBjb21tZW50cyBiZXR3ZWVuIHRoZSBsYXN0IHRva2VuIGFuZCB0aGUgY3VycmVudCB0b2tlbi5cbiAgICAgICAgLy9TbyB3ZSByZXBsYWNlIGNvbW1lbnRzIHdpdGggc3BhY2Ugc3ltYm9scyB0byBjYWxjdWxhdGUgZml4ZWQgcG9zaXRpb24uXG4gICAgICAgIC8vV2UganVzdCBpbmNyZW1lbnQgcG9zaXRpb24gdW50aWwgd2UgbWVldCBub24gd2hpdGVzcGFjZSBjaGFyYWN0ZXJzXG4gICAgICAgIHRoaXMuY29kZUFyciAgICAgICAgICAgICA9IGNvZGUuc3BsaXQoJ1xcbicpO1xuICAgICAgICB0aGlzLmNvZGVXaXRob3V0Q29tbWVudHMgPSByZXBsYWNlQ29tbWVudHMoY29kZSk7XG5cbiAgICAgICAgY29uc3Qgc291cmNlRmlsZSA9IHRzLmNyZWF0ZVNvdXJjZUZpbGUoJycsIGNvZGUsIFR5cGVTY3JpcHRUZXN0RmlsZUNvbXBpbGVyLl9nZXRUeXBlc2NyaXB0T3B0aW9ucygpLCB0cnVlKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5hbmFseXplKHNvdXJjZUZpbGUuc3RhdGVtZW50cyk7XG4gICAgfVxufVxuXG5jb25zdCBwYXJzZXIgPSBuZXcgVHlwZVNjcmlwdFRlc3RGaWxlUGFyc2VyKCk7XG5cbmV4cG9ydCBjb25zdCBnZXRUeXBlU2NyaXB0VGVzdExpc3QgICAgICAgICA9IHBhcnNlci5nZXRUZXN0TGlzdC5iaW5kKHBhcnNlcik7XG5leHBvcnQgY29uc3QgZ2V0VHlwZVNjcmlwdFRlc3RMaXN0RnJvbUNvZGUgPSBwYXJzZXIuZ2V0VGVzdExpc3RGcm9tQ29kZS5iaW5kKHBhcnNlcik7XG4iXX0=
