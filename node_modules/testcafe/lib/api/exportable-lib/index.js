'use strict';

exports.__esModule = true;
const lazyRequire = require('import-lazy')(require);
const ClientFunctionBuilder = lazyRequire('../../client-functions/client-function-builder');
const SelectorBuilder = lazyRequire('../../client-functions/selectors/selector-builder');
const role = lazyRequire('../../role');
const createRequestLogger = lazyRequire('../request-hooks/request-logger');
const createRequestMock = lazyRequire('../request-hooks/request-mock');

// NOTE: We can't use lazy require for RequestHook, because it will break base class detection for inherited classes
let RequestHook = null;

// NOTE: We can't use lazy require for testControllerProxy, because it will break test controller detection
let testControllerProxy = null;

function Role(loginPage, initFn, options) {
    return role.createRole(loginPage, initFn, options);
}

function RequestMock() {
    return createRequestMock();
}

function RequestLogger(requestFilterRuleInit, logOptions) {
    return createRequestLogger(requestFilterRuleInit, logOptions);
}

function ClientFunction(fn, options) {
    const builder = new ClientFunctionBuilder(fn, options, { instantiation: 'ClientFunction' });

    return builder.getFunction();
}

function Selector(fn, options) {
    const builder = new SelectorBuilder(fn, options, { instantiation: 'Selector' });

    return builder.getFunction();
}

Object.defineProperty(Role, 'anonymous', {
    get: () => role.createAnonymousRole
});

exports.default = {
    Role,

    ClientFunction,

    Selector,

    RequestLogger,

    RequestMock,

    get RequestHook() {
        if (!RequestHook) RequestHook = require('../request-hooks/hook');

        return RequestHook;
    },

    get t() {
        if (!testControllerProxy) testControllerProxy = require('../test-controller/proxy');

        return testControllerProxy;
    }
};
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9hcGkvZXhwb3J0YWJsZS1saWIvaW5kZXguanMiXSwibmFtZXMiOlsibGF6eVJlcXVpcmUiLCJyZXF1aXJlIiwiQ2xpZW50RnVuY3Rpb25CdWlsZGVyIiwiU2VsZWN0b3JCdWlsZGVyIiwicm9sZSIsImNyZWF0ZVJlcXVlc3RMb2dnZXIiLCJjcmVhdGVSZXF1ZXN0TW9jayIsIlJlcXVlc3RIb29rIiwidGVzdENvbnRyb2xsZXJQcm94eSIsIlJvbGUiLCJsb2dpblBhZ2UiLCJpbml0Rm4iLCJvcHRpb25zIiwiY3JlYXRlUm9sZSIsIlJlcXVlc3RNb2NrIiwiUmVxdWVzdExvZ2dlciIsInJlcXVlc3RGaWx0ZXJSdWxlSW5pdCIsImxvZ09wdGlvbnMiLCJDbGllbnRGdW5jdGlvbiIsImZuIiwiYnVpbGRlciIsImluc3RhbnRpYXRpb24iLCJnZXRGdW5jdGlvbiIsIlNlbGVjdG9yIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJjcmVhdGVBbm9ueW1vdXNSb2xlIiwidCJdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsTUFBTUEsY0FBd0JDLFFBQVEsYUFBUixFQUF1QkEsT0FBdkIsQ0FBOUI7QUFDQSxNQUFNQyx3QkFBd0JGLFlBQVksZ0RBQVosQ0FBOUI7QUFDQSxNQUFNRyxrQkFBd0JILFlBQVksbURBQVosQ0FBOUI7QUFDQSxNQUFNSSxPQUF3QkosWUFBWSxZQUFaLENBQTlCO0FBQ0EsTUFBTUssc0JBQXdCTCxZQUFZLGlDQUFaLENBQTlCO0FBQ0EsTUFBTU0sb0JBQXdCTixZQUFZLCtCQUFaLENBQTlCOztBQUVBO0FBQ0EsSUFBSU8sY0FBYyxJQUFsQjs7QUFFQTtBQUNBLElBQUlDLHNCQUFzQixJQUExQjs7QUFFQSxTQUFTQyxJQUFULENBQWVDLFNBQWYsRUFBMEJDLE1BQTFCLEVBQWtDQyxPQUFsQyxFQUEyQztBQUN2QyxXQUFPUixLQUFLUyxVQUFMLENBQWdCSCxTQUFoQixFQUEyQkMsTUFBM0IsRUFBbUNDLE9BQW5DLENBQVA7QUFDSDs7QUFFRCxTQUFTRSxXQUFULEdBQXdCO0FBQ3BCLFdBQU9SLG1CQUFQO0FBQ0g7O0FBRUQsU0FBU1MsYUFBVCxDQUF3QkMscUJBQXhCLEVBQStDQyxVQUEvQyxFQUEyRDtBQUN2RCxXQUFPWixvQkFBb0JXLHFCQUFwQixFQUEyQ0MsVUFBM0MsQ0FBUDtBQUNIOztBQUVELFNBQVNDLGNBQVQsQ0FBeUJDLEVBQXpCLEVBQTZCUCxPQUE3QixFQUFzQztBQUNsQyxVQUFNUSxVQUFVLElBQUlsQixxQkFBSixDQUEwQmlCLEVBQTFCLEVBQThCUCxPQUE5QixFQUF1QyxFQUFFUyxlQUFlLGdCQUFqQixFQUF2QyxDQUFoQjs7QUFFQSxXQUFPRCxRQUFRRSxXQUFSLEVBQVA7QUFDSDs7QUFFRCxTQUFTQyxRQUFULENBQW1CSixFQUFuQixFQUF1QlAsT0FBdkIsRUFBZ0M7QUFDNUIsVUFBTVEsVUFBVSxJQUFJakIsZUFBSixDQUFvQmdCLEVBQXBCLEVBQXdCUCxPQUF4QixFQUFpQyxFQUFFUyxlQUFlLFVBQWpCLEVBQWpDLENBQWhCOztBQUVBLFdBQU9ELFFBQVFFLFdBQVIsRUFBUDtBQUNIOztBQUVERSxPQUFPQyxjQUFQLENBQXNCaEIsSUFBdEIsRUFBNEIsV0FBNUIsRUFBeUM7QUFDckNpQixTQUFLLE1BQU10QixLQUFLdUI7QUFEcUIsQ0FBekM7O2tCQUllO0FBQ1hsQixRQURXOztBQUdYUyxrQkFIVzs7QUFLWEssWUFMVzs7QUFPWFIsaUJBUFc7O0FBU1hELGVBVFc7O0FBV1gsUUFBSVAsV0FBSixHQUFtQjtBQUNmLFlBQUksQ0FBQ0EsV0FBTCxFQUNJQSxjQUFjTixRQUFRLHVCQUFSLENBQWQ7O0FBRUosZUFBT00sV0FBUDtBQUNILEtBaEJVOztBQWtCWCxRQUFJcUIsQ0FBSixHQUFTO0FBQ0wsWUFBSSxDQUFDcEIsbUJBQUwsRUFDSUEsc0JBQXNCUCxRQUFRLDBCQUFSLENBQXRCOztBQUVKLGVBQU9PLG1CQUFQO0FBQ0g7QUF2QlUsQyIsImZpbGUiOiJhcGkvZXhwb3J0YWJsZS1saWIvaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBsYXp5UmVxdWlyZSAgICAgICAgICAgPSByZXF1aXJlKCdpbXBvcnQtbGF6eScpKHJlcXVpcmUpO1xuY29uc3QgQ2xpZW50RnVuY3Rpb25CdWlsZGVyID0gbGF6eVJlcXVpcmUoJy4uLy4uL2NsaWVudC1mdW5jdGlvbnMvY2xpZW50LWZ1bmN0aW9uLWJ1aWxkZXInKTtcbmNvbnN0IFNlbGVjdG9yQnVpbGRlciAgICAgICA9IGxhenlSZXF1aXJlKCcuLi8uLi9jbGllbnQtZnVuY3Rpb25zL3NlbGVjdG9ycy9zZWxlY3Rvci1idWlsZGVyJyk7XG5jb25zdCByb2xlICAgICAgICAgICAgICAgICAgPSBsYXp5UmVxdWlyZSgnLi4vLi4vcm9sZScpO1xuY29uc3QgY3JlYXRlUmVxdWVzdExvZ2dlciAgID0gbGF6eVJlcXVpcmUoJy4uL3JlcXVlc3QtaG9va3MvcmVxdWVzdC1sb2dnZXInKTtcbmNvbnN0IGNyZWF0ZVJlcXVlc3RNb2NrICAgICA9IGxhenlSZXF1aXJlKCcuLi9yZXF1ZXN0LWhvb2tzL3JlcXVlc3QtbW9jaycpO1xuXG4vLyBOT1RFOiBXZSBjYW4ndCB1c2UgbGF6eSByZXF1aXJlIGZvciBSZXF1ZXN0SG9vaywgYmVjYXVzZSBpdCB3aWxsIGJyZWFrIGJhc2UgY2xhc3MgZGV0ZWN0aW9uIGZvciBpbmhlcml0ZWQgY2xhc3Nlc1xubGV0IFJlcXVlc3RIb29rID0gbnVsbDtcblxuLy8gTk9URTogV2UgY2FuJ3QgdXNlIGxhenkgcmVxdWlyZSBmb3IgdGVzdENvbnRyb2xsZXJQcm94eSwgYmVjYXVzZSBpdCB3aWxsIGJyZWFrIHRlc3QgY29udHJvbGxlciBkZXRlY3Rpb25cbmxldCB0ZXN0Q29udHJvbGxlclByb3h5ID0gbnVsbDtcblxuZnVuY3Rpb24gUm9sZSAobG9naW5QYWdlLCBpbml0Rm4sIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gcm9sZS5jcmVhdGVSb2xlKGxvZ2luUGFnZSwgaW5pdEZuLCBvcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gUmVxdWVzdE1vY2sgKCkge1xuICAgIHJldHVybiBjcmVhdGVSZXF1ZXN0TW9jaygpO1xufVxuXG5mdW5jdGlvbiBSZXF1ZXN0TG9nZ2VyIChyZXF1ZXN0RmlsdGVyUnVsZUluaXQsIGxvZ09wdGlvbnMpIHtcbiAgICByZXR1cm4gY3JlYXRlUmVxdWVzdExvZ2dlcihyZXF1ZXN0RmlsdGVyUnVsZUluaXQsIGxvZ09wdGlvbnMpO1xufVxuXG5mdW5jdGlvbiBDbGllbnRGdW5jdGlvbiAoZm4sIG9wdGlvbnMpIHtcbiAgICBjb25zdCBidWlsZGVyID0gbmV3IENsaWVudEZ1bmN0aW9uQnVpbGRlcihmbiwgb3B0aW9ucywgeyBpbnN0YW50aWF0aW9uOiAnQ2xpZW50RnVuY3Rpb24nIH0pO1xuXG4gICAgcmV0dXJuIGJ1aWxkZXIuZ2V0RnVuY3Rpb24oKTtcbn1cblxuZnVuY3Rpb24gU2VsZWN0b3IgKGZuLCBvcHRpb25zKSB7XG4gICAgY29uc3QgYnVpbGRlciA9IG5ldyBTZWxlY3RvckJ1aWxkZXIoZm4sIG9wdGlvbnMsIHsgaW5zdGFudGlhdGlvbjogJ1NlbGVjdG9yJyB9KTtcblxuICAgIHJldHVybiBidWlsZGVyLmdldEZ1bmN0aW9uKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSb2xlLCAnYW5vbnltb3VzJywge1xuICAgIGdldDogKCkgPT4gcm9sZS5jcmVhdGVBbm9ueW1vdXNSb2xlXG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIFJvbGUsXG5cbiAgICBDbGllbnRGdW5jdGlvbixcblxuICAgIFNlbGVjdG9yLFxuXG4gICAgUmVxdWVzdExvZ2dlcixcblxuICAgIFJlcXVlc3RNb2NrLFxuXG4gICAgZ2V0IFJlcXVlc3RIb29rICgpIHtcbiAgICAgICAgaWYgKCFSZXF1ZXN0SG9vaylcbiAgICAgICAgICAgIFJlcXVlc3RIb29rID0gcmVxdWlyZSgnLi4vcmVxdWVzdC1ob29rcy9ob29rJyk7XG5cbiAgICAgICAgcmV0dXJuIFJlcXVlc3RIb29rO1xuICAgIH0sXG5cbiAgICBnZXQgdCAoKSB7XG4gICAgICAgIGlmICghdGVzdENvbnRyb2xsZXJQcm94eSlcbiAgICAgICAgICAgIHRlc3RDb250cm9sbGVyUHJveHkgPSByZXF1aXJlKCcuLi90ZXN0LWNvbnRyb2xsZXIvcHJveHknKTtcblxuICAgICAgICByZXR1cm4gdGVzdENvbnRyb2xsZXJQcm94eTtcbiAgICB9XG59O1xuIl19
