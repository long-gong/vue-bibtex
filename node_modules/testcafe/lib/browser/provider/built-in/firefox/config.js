'use strict';

exports.__esModule = true;

var _assign = require('babel-runtime/core-js/object/assign');

var _assign2 = _interopRequireDefault(_assign);

exports.default = function (configString) {
    if (!configCache[configString]) configCache[configString] = getNewConfig(configString);

    return configCache[configString];
};

var _argumentParsing = require('../../utils/argument-parsing');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const AVAILABLE_MODES = ['userProfile', 'headless'];

const configCache = {};

function hasCustomProfile(userArgs) {
    return !!(userArgs.match(/-P\s/) || userArgs.match(/-profile\s/));
}

function parseModes(modesStr, userArgs) {
    const parsed = (0, _argumentParsing.splitEscaped)(modesStr, ':');
    const path = (0, _argumentParsing.getPathFromParsedModes)(parsed, AVAILABLE_MODES);
    const detectedModes = (0, _argumentParsing.getModes)(parsed, AVAILABLE_MODES);
    const optionsString = parsed.filter(item => !!item).join(':');
    const options = parsed.length ? (0, _argumentParsing.splitEscaped)(optionsString, ';') : [];

    return {
        path: path,
        userProfile: detectedModes.userProfile || hasCustomProfile(userArgs),
        headless: detectedModes.headless,
        marionettePort: (0, _argumentParsing.findMatch)(options, /^marionettePort=(.*)/),
        disableMultiprocessing: (0, _argumentParsing.isMatchTrue)(options, /^disableMultiprocessing=(.*)/)
    };
}

function getNewConfig(configString) {
    var _parseConfig = (0, _argumentParsing.parseConfig)(configString);

    const userArgs = _parseConfig.userArgs,
          modesString = _parseConfig.modesString;

    const modes = parseModes(modesString, userArgs);

    return (0, _assign2.default)({ userArgs }, modes);
}

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3NyYy9icm93c2VyL3Byb3ZpZGVyL2J1aWx0LWluL2ZpcmVmb3gvY29uZmlnLmpzIl0sIm5hbWVzIjpbImNvbmZpZ1N0cmluZyIsImNvbmZpZ0NhY2hlIiwiZ2V0TmV3Q29uZmlnIiwiQVZBSUxBQkxFX01PREVTIiwiaGFzQ3VzdG9tUHJvZmlsZSIsInVzZXJBcmdzIiwibWF0Y2giLCJwYXJzZU1vZGVzIiwibW9kZXNTdHIiLCJwYXJzZWQiLCJwYXRoIiwiZGV0ZWN0ZWRNb2RlcyIsIm9wdGlvbnNTdHJpbmciLCJmaWx0ZXIiLCJpdGVtIiwiam9pbiIsIm9wdGlvbnMiLCJsZW5ndGgiLCJ1c2VyUHJvZmlsZSIsImhlYWRsZXNzIiwibWFyaW9uZXR0ZVBvcnQiLCJkaXNhYmxlTXVsdGlwcm9jZXNzaW5nIiwibW9kZXNTdHJpbmciLCJtb2RlcyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7a0JBbUNlLFVBQVVBLFlBQVYsRUFBd0I7QUFDbkMsUUFBSSxDQUFDQyxZQUFZRCxZQUFaLENBQUwsRUFDSUMsWUFBWUQsWUFBWixJQUE0QkUsYUFBYUYsWUFBYixDQUE1Qjs7QUFFSixXQUFPQyxZQUFZRCxZQUFaLENBQVA7QUFDSCxDOztBQXhDRDs7OztBQUdBLE1BQU1HLGtCQUFrQixDQUFDLGFBQUQsRUFBZ0IsVUFBaEIsQ0FBeEI7O0FBRUEsTUFBTUYsY0FBYyxFQUFwQjs7QUFFQSxTQUFTRyxnQkFBVCxDQUEyQkMsUUFBM0IsRUFBcUM7QUFDakMsV0FBTyxDQUFDLEVBQUVBLFNBQVNDLEtBQVQsQ0FBZSxNQUFmLEtBQTBCRCxTQUFTQyxLQUFULENBQWUsWUFBZixDQUE1QixDQUFSO0FBQ0g7O0FBRUQsU0FBU0MsVUFBVCxDQUFxQkMsUUFBckIsRUFBK0JILFFBQS9CLEVBQXlDO0FBQ3JDLFVBQU1JLFNBQWdCLG1DQUFhRCxRQUFiLEVBQXVCLEdBQXZCLENBQXRCO0FBQ0EsVUFBTUUsT0FBZ0IsNkNBQXVCRCxNQUF2QixFQUErQk4sZUFBL0IsQ0FBdEI7QUFDQSxVQUFNUSxnQkFBZ0IsK0JBQVNGLE1BQVQsRUFBaUJOLGVBQWpCLENBQXRCO0FBQ0EsVUFBTVMsZ0JBQWdCSCxPQUFPSSxNQUFQLENBQWNDLFFBQVEsQ0FBQyxDQUFDQSxJQUF4QixFQUE4QkMsSUFBOUIsQ0FBbUMsR0FBbkMsQ0FBdEI7QUFDQSxVQUFNQyxVQUFnQlAsT0FBT1EsTUFBUCxHQUFnQixtQ0FBYUwsYUFBYixFQUE0QixHQUE1QixDQUFoQixHQUFtRCxFQUF6RTs7QUFFQSxXQUFPO0FBQ0hGLGNBQXdCQSxJQURyQjtBQUVIUSxxQkFBd0JQLGNBQWNPLFdBQWQsSUFBNkJkLGlCQUFpQkMsUUFBakIsQ0FGbEQ7QUFHSGMsa0JBQXdCUixjQUFjUSxRQUhuQztBQUlIQyx3QkFBd0IsZ0NBQVVKLE9BQVYsRUFBbUIsc0JBQW5CLENBSnJCO0FBS0hLLGdDQUF3QixrQ0FBWUwsT0FBWixFQUFxQiw4QkFBckI7QUFMckIsS0FBUDtBQU9IOztBQUdELFNBQVNkLFlBQVQsQ0FBdUJGLFlBQXZCLEVBQXFDO0FBQUEsdUJBQ0Msa0NBQVlBLFlBQVosQ0FERDs7QUFBQSxVQUN6QkssUUFEeUIsZ0JBQ3pCQSxRQUR5QjtBQUFBLFVBQ2ZpQixXQURlLGdCQUNmQSxXQURlOztBQUVqQyxVQUFNQyxRQUE0QmhCLFdBQVdlLFdBQVgsRUFBd0JqQixRQUF4QixDQUFsQzs7QUFFQSxXQUFPLHNCQUFjLEVBQUVBLFFBQUYsRUFBZCxFQUE0QmtCLEtBQTVCLENBQVA7QUFDSCIsImZpbGUiOiJicm93c2VyL3Byb3ZpZGVyL2J1aWx0LWluL2ZpcmVmb3gvY29uZmlnLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZmluZE1hdGNoLCBpc01hdGNoVHJ1ZSwgc3BsaXRFc2NhcGVkLCBwYXJzZUNvbmZpZywgZ2V0TW9kZXMsIGdldFBhdGhGcm9tUGFyc2VkTW9kZXMgfSBmcm9tICcuLi8uLi91dGlscy9hcmd1bWVudC1wYXJzaW5nJztcblxuXG5jb25zdCBBVkFJTEFCTEVfTU9ERVMgPSBbJ3VzZXJQcm9maWxlJywgJ2hlYWRsZXNzJ107XG5cbmNvbnN0IGNvbmZpZ0NhY2hlID0ge307XG5cbmZ1bmN0aW9uIGhhc0N1c3RvbVByb2ZpbGUgKHVzZXJBcmdzKSB7XG4gICAgcmV0dXJuICEhKHVzZXJBcmdzLm1hdGNoKC8tUFxccy8pIHx8IHVzZXJBcmdzLm1hdGNoKC8tcHJvZmlsZVxccy8pKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RlcyAobW9kZXNTdHIsIHVzZXJBcmdzKSB7XG4gICAgY29uc3QgcGFyc2VkICAgICAgICA9IHNwbGl0RXNjYXBlZChtb2Rlc1N0ciwgJzonKTtcbiAgICBjb25zdCBwYXRoICAgICAgICAgID0gZ2V0UGF0aEZyb21QYXJzZWRNb2RlcyhwYXJzZWQsIEFWQUlMQUJMRV9NT0RFUyk7XG4gICAgY29uc3QgZGV0ZWN0ZWRNb2RlcyA9IGdldE1vZGVzKHBhcnNlZCwgQVZBSUxBQkxFX01PREVTKTtcbiAgICBjb25zdCBvcHRpb25zU3RyaW5nID0gcGFyc2VkLmZpbHRlcihpdGVtID0+ICEhaXRlbSkuam9pbignOicpO1xuICAgIGNvbnN0IG9wdGlvbnMgICAgICAgPSBwYXJzZWQubGVuZ3RoID8gc3BsaXRFc2NhcGVkKG9wdGlvbnNTdHJpbmcsICc7JykgOiBbXTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHBhdGg6ICAgICAgICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgIHVzZXJQcm9maWxlOiAgICAgICAgICAgIGRldGVjdGVkTW9kZXMudXNlclByb2ZpbGUgfHwgaGFzQ3VzdG9tUHJvZmlsZSh1c2VyQXJncyksXG4gICAgICAgIGhlYWRsZXNzOiAgICAgICAgICAgICAgIGRldGVjdGVkTW9kZXMuaGVhZGxlc3MsXG4gICAgICAgIG1hcmlvbmV0dGVQb3J0OiAgICAgICAgIGZpbmRNYXRjaChvcHRpb25zLCAvXm1hcmlvbmV0dGVQb3J0PSguKikvKSxcbiAgICAgICAgZGlzYWJsZU11bHRpcHJvY2Vzc2luZzogaXNNYXRjaFRydWUob3B0aW9ucywgL15kaXNhYmxlTXVsdGlwcm9jZXNzaW5nPSguKikvKVxuICAgIH07XG59XG5cblxuZnVuY3Rpb24gZ2V0TmV3Q29uZmlnIChjb25maWdTdHJpbmcpIHtcbiAgICBjb25zdCB7IHVzZXJBcmdzLCBtb2Rlc1N0cmluZyB9ID0gcGFyc2VDb25maWcoY29uZmlnU3RyaW5nKTtcbiAgICBjb25zdCBtb2RlcyAgICAgICAgICAgICAgICAgICAgID0gcGFyc2VNb2Rlcyhtb2Rlc1N0cmluZywgdXNlckFyZ3MpO1xuXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyB1c2VyQXJncyB9LCBtb2Rlcyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChjb25maWdTdHJpbmcpIHtcbiAgICBpZiAoIWNvbmZpZ0NhY2hlW2NvbmZpZ1N0cmluZ10pXG4gICAgICAgIGNvbmZpZ0NhY2hlW2NvbmZpZ1N0cmluZ10gPSBnZXROZXdDb25maWcoY29uZmlnU3RyaW5nKTtcblxuICAgIHJldHVybiBjb25maWdDYWNoZVtjb25maWdTdHJpbmddO1xufVxuIl19
