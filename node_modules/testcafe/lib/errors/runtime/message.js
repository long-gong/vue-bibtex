'use strict';

exports.__esModule = true;
// -------------------------------------------------------------
// WARNING: this file is used by both the client and the server.
// Do not use any browser or node-specific API!
// -------------------------------------------------------------


exports.default = {
    browserDisconnected: 'The {userAgent} browser disconnected. This problem may appear when a browser hangs or is closed, or due to network issues.',
    cantRunAgainstDisconnectedBrowsers: 'The following browsers disconnected: {userAgents}. Tests will not be run.',
    cantEstablishBrowserConnection: 'Unable to establish one or more of the specified browser connections. This can be caused by network issues or remote device failure.',
    cantFindBrowser: 'Unable to find the browser. "{browser}" is not a browser alias or path to an executable file.',
    browserProviderNotFound: 'The specified "{providerName}" browser provider was not found.',
    browserNotSet: 'No browser selected to test against.',
    testSourcesNotSet: 'No test file specified.',
    noTestsToRun: 'No tests to run. Either the test files contain no tests or the filter function is too restrictive.',
    cantFindReporterForAlias: 'The provided "{name}" reporter does not exist. Check that you have specified the report format correctly.',
    multipleStdoutReporters: 'Multiple reporters attempting to write to stdout: "{reporters}". Only one reporter can write to stdout.',
    optionValueIsNotValidRegExp: 'The "{optionName}" option value is not a valid regular expression.',
    optionValueIsNotValidKeyValue: 'The "{optionName}" option value is not a valid key-value pair.',
    testedAppFailedWithError: 'Tested app failed with an error:\n\n{errMessage}',
    invalidSpeedValue: 'Speed should be a number between 0.01 and 1.',
    invalidConcurrencyFactor: 'The concurrency factor should be an integer greater or equal to 1.',
    cannotDivideRemotesCountByConcurrency: 'The number of remote browsers should be divisible by the factor of concurrency.',
    portsOptionRequiresTwoNumbers: 'The "--ports" option requires two numbers to be specified.',
    portIsNotFree: 'The specified {portNum} port is already in use by another program.',
    invalidHostname: 'The specified "{hostname}" hostname cannot be resolved to the current machine.',
    cantFindSpecifiedTestSource: 'Cannot find a test source file at "{path}".',
    cannotParseRawFile: 'Cannot parse a test source file in the raw format at "{path}" due to an error.\n\n{errMessage}',
    cannotPrepareTestsDueToError: 'Cannot prepare tests due to an error.\n\n{errMessage}',
    clientFunctionCodeIsNotAFunction: '{#instantiationCallsiteName} code is expected to be specified as a function, but {type} was passed.',
    selectorInitializedWithWrongType: '{#instantiationCallsiteName} is expected to be initialized with a function, CSS selector string, another Selector, node snapshot or a Promise returned by a Selector, but {type} was passed.',
    clientFunctionCantResolveTestRun: "{#instantiationCallsiteName} cannot implicitly resolve the test run in context of which it should be executed. If you need to call {#instantiationCallsiteName} from the Node.js API callback, pass the test controller manually via {#instantiationCallsiteName}'s `.with({ boundTestRun: t })` method first. Note that you cannot execute {#instantiationCallsiteName} outside the test code.",
    regeneratorInClientFunctionCode: `{#instantiationCallsiteName} code, arguments or dependencies cannot contain generators or "async/await" syntax (use Promises instead).`,
    invalidClientFunctionTestRunBinding: 'The "boundTestRun" option value is expected to be a test controller.',
    invalidValueType: '{smthg} is expected to be a {type}, but it was {actual}.',
    unsupportedUrlProtocol: 'The specified "{url}" test page URL uses an unsupported {protocol}:// protocol. Only relative URLs or absolute URLs with http://, https:// and file:// protocols are supported.',
    unableToOpenBrowser: 'Was unable to open the browser "{alias}" due to error.\n\n{errMessage}',
    testControllerProxyCantResolveTestRun: `Cannot implicitly resolve the test run in the context of which the test controller action should be executed. Use test function's 't' argument instead.`,
    requestHookConfigureAPIError: 'There was an error while configuring the request hook:\n\n{requestHookName}: {errMsg}',
    timeLimitedPromiseTimeoutExpired: 'Timeout expired for a time limited promise',
    forbiddenCharatersInScreenshotPath: 'There are forbidden characters in the "{screenshotPath}" {screenshotPathType}:\n {forbiddenCharsDescription}',
    cantUseScreenshotPathPatternWithoutBaseScreenshotPathSpecified: 'Cannot use the screenshot path pattern without a base screenshot path specified'
};
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9lcnJvcnMvcnVudGltZS9tZXNzYWdlLmpzIl0sIm5hbWVzIjpbImJyb3dzZXJEaXNjb25uZWN0ZWQiLCJjYW50UnVuQWdhaW5zdERpc2Nvbm5lY3RlZEJyb3dzZXJzIiwiY2FudEVzdGFibGlzaEJyb3dzZXJDb25uZWN0aW9uIiwiY2FudEZpbmRCcm93c2VyIiwiYnJvd3NlclByb3ZpZGVyTm90Rm91bmQiLCJicm93c2VyTm90U2V0IiwidGVzdFNvdXJjZXNOb3RTZXQiLCJub1Rlc3RzVG9SdW4iLCJjYW50RmluZFJlcG9ydGVyRm9yQWxpYXMiLCJtdWx0aXBsZVN0ZG91dFJlcG9ydGVycyIsIm9wdGlvblZhbHVlSXNOb3RWYWxpZFJlZ0V4cCIsIm9wdGlvblZhbHVlSXNOb3RWYWxpZEtleVZhbHVlIiwidGVzdGVkQXBwRmFpbGVkV2l0aEVycm9yIiwiaW52YWxpZFNwZWVkVmFsdWUiLCJpbnZhbGlkQ29uY3VycmVuY3lGYWN0b3IiLCJjYW5ub3REaXZpZGVSZW1vdGVzQ291bnRCeUNvbmN1cnJlbmN5IiwicG9ydHNPcHRpb25SZXF1aXJlc1R3b051bWJlcnMiLCJwb3J0SXNOb3RGcmVlIiwiaW52YWxpZEhvc3RuYW1lIiwiY2FudEZpbmRTcGVjaWZpZWRUZXN0U291cmNlIiwiY2Fubm90UGFyc2VSYXdGaWxlIiwiY2Fubm90UHJlcGFyZVRlc3RzRHVlVG9FcnJvciIsImNsaWVudEZ1bmN0aW9uQ29kZUlzTm90QUZ1bmN0aW9uIiwic2VsZWN0b3JJbml0aWFsaXplZFdpdGhXcm9uZ1R5cGUiLCJjbGllbnRGdW5jdGlvbkNhbnRSZXNvbHZlVGVzdFJ1biIsInJlZ2VuZXJhdG9ySW5DbGllbnRGdW5jdGlvbkNvZGUiLCJpbnZhbGlkQ2xpZW50RnVuY3Rpb25UZXN0UnVuQmluZGluZyIsImludmFsaWRWYWx1ZVR5cGUiLCJ1bnN1cHBvcnRlZFVybFByb3RvY29sIiwidW5hYmxlVG9PcGVuQnJvd3NlciIsInRlc3RDb250cm9sbGVyUHJveHlDYW50UmVzb2x2ZVRlc3RSdW4iLCJyZXF1ZXN0SG9va0NvbmZpZ3VyZUFQSUVycm9yIiwidGltZUxpbWl0ZWRQcm9taXNlVGltZW91dEV4cGlyZWQiLCJmb3JiaWRkZW5DaGFyYXRlcnNJblNjcmVlbnNob3RQYXRoIiwiY2FudFVzZVNjcmVlbnNob3RQYXRoUGF0dGVybldpdGhvdXRCYXNlU2NyZWVuc2hvdFBhdGhTcGVjaWZpZWQiXSwibWFwcGluZ3MiOiI7OztBQUFBO0FBQ0E7QUFDQTtBQUNBOzs7a0JBR2U7QUFDWEEseUJBQWdFLDRIQURyRDtBQUVYQyx3Q0FBZ0UsMkVBRnJEO0FBR1hDLG9DQUFnRSxzSUFIckQ7QUFJWEMscUJBQWdFLCtGQUpyRDtBQUtYQyw2QkFBZ0UsZ0VBTHJEO0FBTVhDLG1CQUFnRSxzQ0FOckQ7QUFPWEMsdUJBQWdFLHlCQVByRDtBQVFYQyxrQkFBZ0Usb0dBUnJEO0FBU1hDLDhCQUFnRSwyR0FUckQ7QUFVWEMsNkJBQWdFLHlHQVZyRDtBQVdYQyxpQ0FBZ0Usb0VBWHJEO0FBWVhDLG1DQUFnRSxnRUFackQ7QUFhWEMsOEJBQWdFLGtEQWJyRDtBQWNYQyx1QkFBZ0UsOENBZHJEO0FBZVhDLDhCQUFnRSxvRUFmckQ7QUFnQlhDLDJDQUFnRSxpRkFoQnJEO0FBaUJYQyxtQ0FBZ0UsNERBakJyRDtBQWtCWEMsbUJBQWdFLG9FQWxCckQ7QUFtQlhDLHFCQUFnRSxnRkFuQnJEO0FBb0JYQyxpQ0FBZ0UsNkNBcEJyRDtBQXFCWEMsd0JBQWdFLGdHQXJCckQ7QUFzQlhDLGtDQUFnRSx1REF0QnJEO0FBdUJYQyxzQ0FBZ0UscUdBdkJyRDtBQXdCWEMsc0NBQWdFLDhMQXhCckQ7QUF5QlhDLHNDQUFnRSxpWUF6QnJEO0FBMEJYQyxxQ0FBaUUsd0lBMUJ0RDtBQTJCWEMseUNBQWdFLHNFQTNCckQ7QUE0QlhDLHNCQUFnRSwwREE1QnJEO0FBNkJYQyw0QkFBZ0UsaUxBN0JyRDtBQThCWEMseUJBQWdFLHdFQTlCckQ7QUErQlhDLDJDQUFpRSx5SkEvQnREO0FBZ0NYQyxrQ0FBZ0UsdUZBaENyRDtBQWlDWEMsc0NBQWdFLDRDQWpDckQ7QUFrQ1hDLHdDQUFnRSw4R0FsQ3JEO0FBbUNYQyxvRUFBZ0U7QUFuQ3JELEMiLCJmaWxlIjoiZXJyb3JzL3J1bnRpbWUvbWVzc2FnZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFdBUk5JTkc6IHRoaXMgZmlsZSBpcyB1c2VkIGJ5IGJvdGggdGhlIGNsaWVudCBhbmQgdGhlIHNlcnZlci5cbi8vIERvIG5vdCB1c2UgYW55IGJyb3dzZXIgb3Igbm9kZS1zcGVjaWZpYyBBUEkhXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGJyb3dzZXJEaXNjb25uZWN0ZWQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHt1c2VyQWdlbnR9IGJyb3dzZXIgZGlzY29ubmVjdGVkLiBUaGlzIHByb2JsZW0gbWF5IGFwcGVhciB3aGVuIGEgYnJvd3NlciBoYW5ncyBvciBpcyBjbG9zZWQsIG9yIGR1ZSB0byBuZXR3b3JrIGlzc3Vlcy4nLFxuICAgIGNhbnRSdW5BZ2FpbnN0RGlzY29ubmVjdGVkQnJvd3NlcnM6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIGZvbGxvd2luZyBicm93c2VycyBkaXNjb25uZWN0ZWQ6IHt1c2VyQWdlbnRzfS4gVGVzdHMgd2lsbCBub3QgYmUgcnVuLicsXG4gICAgY2FudEVzdGFibGlzaEJyb3dzZXJDb25uZWN0aW9uOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdVbmFibGUgdG8gZXN0YWJsaXNoIG9uZSBvciBtb3JlIG9mIHRoZSBzcGVjaWZpZWQgYnJvd3NlciBjb25uZWN0aW9ucy4gVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IG5ldHdvcmsgaXNzdWVzIG9yIHJlbW90ZSBkZXZpY2UgZmFpbHVyZS4nLFxuICAgIGNhbnRGaW5kQnJvd3NlcjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVW5hYmxlIHRvIGZpbmQgdGhlIGJyb3dzZXIuIFwie2Jyb3dzZXJ9XCIgaXMgbm90IGEgYnJvd3NlciBhbGlhcyBvciBwYXRoIHRvIGFuIGV4ZWN1dGFibGUgZmlsZS4nLFxuICAgIGJyb3dzZXJQcm92aWRlck5vdEZvdW5kOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHNwZWNpZmllZCBcIntwcm92aWRlck5hbWV9XCIgYnJvd3NlciBwcm92aWRlciB3YXMgbm90IGZvdW5kLicsXG4gICAgYnJvd3Nlck5vdFNldDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdObyBicm93c2VyIHNlbGVjdGVkIHRvIHRlc3QgYWdhaW5zdC4nLFxuICAgIHRlc3RTb3VyY2VzTm90U2V0OiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTm8gdGVzdCBmaWxlIHNwZWNpZmllZC4nLFxuICAgIG5vVGVzdHNUb1J1bjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTm8gdGVzdHMgdG8gcnVuLiBFaXRoZXIgdGhlIHRlc3QgZmlsZXMgY29udGFpbiBubyB0ZXN0cyBvciB0aGUgZmlsdGVyIGZ1bmN0aW9uIGlzIHRvbyByZXN0cmljdGl2ZS4nLFxuICAgIGNhbnRGaW5kUmVwb3J0ZXJGb3JBbGlhczogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHByb3ZpZGVkIFwie25hbWV9XCIgcmVwb3J0ZXIgZG9lcyBub3QgZXhpc3QuIENoZWNrIHRoYXQgeW91IGhhdmUgc3BlY2lmaWVkIHRoZSByZXBvcnQgZm9ybWF0IGNvcnJlY3RseS4nLFxuICAgIG11bHRpcGxlU3Rkb3V0UmVwb3J0ZXJzOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnTXVsdGlwbGUgcmVwb3J0ZXJzIGF0dGVtcHRpbmcgdG8gd3JpdGUgdG8gc3Rkb3V0OiBcIntyZXBvcnRlcnN9XCIuIE9ubHkgb25lIHJlcG9ydGVyIGNhbiB3cml0ZSB0byBzdGRvdXQuJyxcbiAgICBvcHRpb25WYWx1ZUlzTm90VmFsaWRSZWdFeHA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBcIntvcHRpb25OYW1lfVwiIG9wdGlvbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCByZWd1bGFyIGV4cHJlc3Npb24uJyxcbiAgICBvcHRpb25WYWx1ZUlzTm90VmFsaWRLZXlWYWx1ZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBcIntvcHRpb25OYW1lfVwiIG9wdGlvbiB2YWx1ZSBpcyBub3QgYSB2YWxpZCBrZXktdmFsdWUgcGFpci4nLFxuICAgIHRlc3RlZEFwcEZhaWxlZFdpdGhFcnJvcjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGVzdGVkIGFwcCBmYWlsZWQgd2l0aCBhbiBlcnJvcjpcXG5cXG57ZXJyTWVzc2FnZX0nLFxuICAgIGludmFsaWRTcGVlZFZhbHVlOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnU3BlZWQgc2hvdWxkIGJlIGEgbnVtYmVyIGJldHdlZW4gMC4wMSBhbmQgMS4nLFxuICAgIGludmFsaWRDb25jdXJyZW5jeUZhY3RvcjogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIGNvbmN1cnJlbmN5IGZhY3RvciBzaG91bGQgYmUgYW4gaW50ZWdlciBncmVhdGVyIG9yIGVxdWFsIHRvIDEuJyxcbiAgICBjYW5ub3REaXZpZGVSZW1vdGVzQ291bnRCeUNvbmN1cnJlbmN5OiAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBudW1iZXIgb2YgcmVtb3RlIGJyb3dzZXJzIHNob3VsZCBiZSBkaXZpc2libGUgYnkgdGhlIGZhY3RvciBvZiBjb25jdXJyZW5jeS4nLFxuICAgIHBvcnRzT3B0aW9uUmVxdWlyZXNUd29OdW1iZXJzOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIFwiLS1wb3J0c1wiIG9wdGlvbiByZXF1aXJlcyB0d28gbnVtYmVycyB0byBiZSBzcGVjaWZpZWQuJyxcbiAgICBwb3J0SXNOb3RGcmVlOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBzcGVjaWZpZWQge3BvcnROdW19IHBvcnQgaXMgYWxyZWFkeSBpbiB1c2UgYnkgYW5vdGhlciBwcm9ncmFtLicsXG4gICAgaW52YWxpZEhvc3RuYW1lOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGUgc3BlY2lmaWVkIFwie2hvc3RuYW1lfVwiIGhvc3RuYW1lIGNhbm5vdCBiZSByZXNvbHZlZCB0byB0aGUgY3VycmVudCBtYWNoaW5lLicsXG4gICAgY2FudEZpbmRTcGVjaWZpZWRUZXN0U291cmNlOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICdDYW5ub3QgZmluZCBhIHRlc3Qgc291cmNlIGZpbGUgYXQgXCJ7cGF0aH1cIi4nLFxuICAgIGNhbm5vdFBhcnNlUmF3RmlsZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IHBhcnNlIGEgdGVzdCBzb3VyY2UgZmlsZSBpbiB0aGUgcmF3IGZvcm1hdCBhdCBcIntwYXRofVwiIGR1ZSB0byBhbiBlcnJvci5cXG5cXG57ZXJyTWVzc2FnZX0nLFxuICAgIGNhbm5vdFByZXBhcmVUZXN0c0R1ZVRvRXJyb3I6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQ2Fubm90IHByZXBhcmUgdGVzdHMgZHVlIHRvIGFuIGVycm9yLlxcblxcbntlcnJNZXNzYWdlfScsXG4gICAgY2xpZW50RnVuY3Rpb25Db2RlSXNOb3RBRnVuY3Rpb246ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGNvZGUgaXMgZXhwZWN0ZWQgdG8gYmUgc3BlY2lmaWVkIGFzIGEgZnVuY3Rpb24sIGJ1dCB7dHlwZX0gd2FzIHBhc3NlZC4nLFxuICAgIHNlbGVjdG9ySW5pdGlhbGl6ZWRXaXRoV3JvbmdUeXBlOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAneyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSBpcyBleHBlY3RlZCB0byBiZSBpbml0aWFsaXplZCB3aXRoIGEgZnVuY3Rpb24sIENTUyBzZWxlY3RvciBzdHJpbmcsIGFub3RoZXIgU2VsZWN0b3IsIG5vZGUgc25hcHNob3Qgb3IgYSBQcm9taXNlIHJldHVybmVkIGJ5IGEgU2VsZWN0b3IsIGJ1dCB7dHlwZX0gd2FzIHBhc3NlZC4nLFxuICAgIGNsaWVudEZ1bmN0aW9uQ2FudFJlc29sdmVUZXN0UnVuOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInsjaW5zdGFudGlhdGlvbkNhbGxzaXRlTmFtZX0gY2Fubm90IGltcGxpY2l0bHkgcmVzb2x2ZSB0aGUgdGVzdCBydW4gaW4gY29udGV4dCBvZiB3aGljaCBpdCBzaG91bGQgYmUgZXhlY3V0ZWQuIElmIHlvdSBuZWVkIHRvIGNhbGwgeyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSBmcm9tIHRoZSBOb2RlLmpzIEFQSSBjYWxsYmFjaywgcGFzcyB0aGUgdGVzdCBjb250cm9sbGVyIG1hbnVhbGx5IHZpYSB7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9J3MgYC53aXRoKHsgYm91bmRUZXN0UnVuOiB0IH0pYCBtZXRob2QgZmlyc3QuIE5vdGUgdGhhdCB5b3UgY2Fubm90IGV4ZWN1dGUgeyNpbnN0YW50aWF0aW9uQ2FsbHNpdGVOYW1lfSBvdXRzaWRlIHRoZSB0ZXN0IGNvZGUuXCIsXG4gICAgcmVnZW5lcmF0b3JJbkNsaWVudEZ1bmN0aW9uQ29kZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGB7I2luc3RhbnRpYXRpb25DYWxsc2l0ZU5hbWV9IGNvZGUsIGFyZ3VtZW50cyBvciBkZXBlbmRlbmNpZXMgY2Fubm90IGNvbnRhaW4gZ2VuZXJhdG9ycyBvciBcImFzeW5jL2F3YWl0XCIgc3ludGF4ICh1c2UgUHJvbWlzZXMgaW5zdGVhZCkuYCxcbiAgICBpbnZhbGlkQ2xpZW50RnVuY3Rpb25UZXN0UnVuQmluZGluZzogICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RoZSBcImJvdW5kVGVzdFJ1blwiIG9wdGlvbiB2YWx1ZSBpcyBleHBlY3RlZCB0byBiZSBhIHRlc3QgY29udHJvbGxlci4nLFxuICAgIGludmFsaWRWYWx1ZVR5cGU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAne3NtdGhnfSBpcyBleHBlY3RlZCB0byBiZSBhIHt0eXBlfSwgYnV0IGl0IHdhcyB7YWN0dWFsfS4nLFxuICAgIHVuc3VwcG9ydGVkVXJsUHJvdG9jb2w6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlIHNwZWNpZmllZCBcInt1cmx9XCIgdGVzdCBwYWdlIFVSTCB1c2VzIGFuIHVuc3VwcG9ydGVkIHtwcm90b2NvbH06Ly8gcHJvdG9jb2wuIE9ubHkgcmVsYXRpdmUgVVJMcyBvciBhYnNvbHV0ZSBVUkxzIHdpdGggaHR0cDovLywgaHR0cHM6Ly8gYW5kIGZpbGU6Ly8gcHJvdG9jb2xzIGFyZSBzdXBwb3J0ZWQuJyxcbiAgICB1bmFibGVUb09wZW5Ccm93c2VyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1dhcyB1bmFibGUgdG8gb3BlbiB0aGUgYnJvd3NlciBcInthbGlhc31cIiBkdWUgdG8gZXJyb3IuXFxuXFxue2Vyck1lc3NhZ2V9JyxcbiAgICB0ZXN0Q29udHJvbGxlclByb3h5Q2FudFJlc29sdmVUZXN0UnVuOiAgICAgICAgICAgICAgICAgICAgICAgICAgYENhbm5vdCBpbXBsaWNpdGx5IHJlc29sdmUgdGhlIHRlc3QgcnVuIGluIHRoZSBjb250ZXh0IG9mIHdoaWNoIHRoZSB0ZXN0IGNvbnRyb2xsZXIgYWN0aW9uIHNob3VsZCBiZSBleGVjdXRlZC4gVXNlIHRlc3QgZnVuY3Rpb24ncyAndCcgYXJndW1lbnQgaW5zdGVhZC5gLFxuICAgIHJlcXVlc3RIb29rQ29uZmlndXJlQVBJRXJyb3I6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGNvbmZpZ3VyaW5nIHRoZSByZXF1ZXN0IGhvb2s6XFxuXFxue3JlcXVlc3RIb29rTmFtZX06IHtlcnJNc2d9JyxcbiAgICB0aW1lTGltaXRlZFByb21pc2VUaW1lb3V0RXhwaXJlZDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1RpbWVvdXQgZXhwaXJlZCBmb3IgYSB0aW1lIGxpbWl0ZWQgcHJvbWlzZScsXG4gICAgZm9yYmlkZGVuQ2hhcmF0ZXJzSW5TY3JlZW5zaG90UGF0aDogICAgICAgICAgICAgICAgICAgICAgICAgICAgICdUaGVyZSBhcmUgZm9yYmlkZGVuIGNoYXJhY3RlcnMgaW4gdGhlIFwie3NjcmVlbnNob3RQYXRofVwiIHtzY3JlZW5zaG90UGF0aFR5cGV9OlxcbiB7Zm9yYmlkZGVuQ2hhcnNEZXNjcmlwdGlvbn0nLFxuICAgIGNhbnRVc2VTY3JlZW5zaG90UGF0aFBhdHRlcm5XaXRob3V0QmFzZVNjcmVlbnNob3RQYXRoU3BlY2lmaWVkOiAnQ2Fubm90IHVzZSB0aGUgc2NyZWVuc2hvdCBwYXRoIHBhdHRlcm4gd2l0aG91dCBhIGJhc2Ugc2NyZWVuc2hvdCBwYXRoIHNwZWNpZmllZCdcbn07XG4iXX0=
