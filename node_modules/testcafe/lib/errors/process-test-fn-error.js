'use strict';

exports.__esModule = true;
exports.default = processTestFnError;

var _path = require('path');

var _getCallsite = require('./get-callsite');

var _runtime = require('./runtime');

var _errorList = require('./error-list');

var _errorList2 = _interopRequireDefault(_errorList);

var _testRun = require('./test-run');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const INTERNAL = 'internal/';

function isAssertionErrorCallsiteFrame(frame) {
    const filename = frame.getFileName();

    // NOTE: filter out the internals of node.js and assertion libraries
    return filename && filename.indexOf(_path.sep) > -1 && filename.indexOf(INTERNAL) !== 0 && filename.indexOf(`${_path.sep}node_modules${_path.sep}`) < 0;
}

function processTestFnError(err) {
    if (err && (err.isTestCafeError || err instanceof _errorList2.default)) return err;

    if (err && err.constructor === _runtime.APIError) return new _testRun.UncaughtErrorInTestCode(err.rawMessage, err.callsite);

    if (err instanceof Error) {
        const isAssertionError = err.name === 'AssertionError' || err.constructor.name === 'AssertionError';

        // NOTE: assertion libraries can add their source files to the error stack frames.
        // We should skip them to create a correct callsite for the assertion error.
        const callsite = isAssertionError ? (0, _getCallsite.getCallsiteForError)(err, isAssertionErrorCallsiteFrame) : (0, _getCallsite.getCallsiteForError)(err);

        return isAssertionError ? new _testRun.ExternalAssertionLibraryError(err, callsite) : new _testRun.UncaughtErrorInTestCode(err, callsite);
    }

    return new _testRun.UncaughtNonErrorObjectInTestCode(err);
}
module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9lcnJvcnMvcHJvY2Vzcy10ZXN0LWZuLWVycm9yLmpzIl0sIm5hbWVzIjpbInByb2Nlc3NUZXN0Rm5FcnJvciIsIklOVEVSTkFMIiwiaXNBc3NlcnRpb25FcnJvckNhbGxzaXRlRnJhbWUiLCJmcmFtZSIsImZpbGVuYW1lIiwiZ2V0RmlsZU5hbWUiLCJpbmRleE9mIiwic2VwIiwiZXJyIiwiaXNUZXN0Q2FmZUVycm9yIiwiVGVzdENhZmVFcnJvckxpc3QiLCJjb25zdHJ1Y3RvciIsIkFQSUVycm9yIiwiVW5jYXVnaHRFcnJvckluVGVzdENvZGUiLCJyYXdNZXNzYWdlIiwiY2FsbHNpdGUiLCJFcnJvciIsImlzQXNzZXJ0aW9uRXJyb3IiLCJuYW1lIiwiRXh0ZXJuYWxBc3NlcnRpb25MaWJyYXJ5RXJyb3IiLCJVbmNhdWdodE5vbkVycm9yT2JqZWN0SW5UZXN0Q29kZSJdLCJtYXBwaW5ncyI6Ijs7O2tCQXlCd0JBLGtCOztBQXpCeEI7O0FBQ0E7O0FBQ0E7O0FBQ0E7Ozs7QUFFQTs7OztBQU9BLE1BQU1DLFdBQVcsV0FBakI7O0FBRUEsU0FBU0MsNkJBQVQsQ0FBd0NDLEtBQXhDLEVBQStDO0FBQzNDLFVBQU1DLFdBQVdELE1BQU1FLFdBQU4sRUFBakI7O0FBRUE7QUFDQSxXQUFPRCxZQUNBQSxTQUFTRSxPQUFULENBQWlCQyxTQUFqQixJQUF3QixDQUFDLENBRHpCLElBRUFILFNBQVNFLE9BQVQsQ0FBaUJMLFFBQWpCLE1BQStCLENBRi9CLElBR0FHLFNBQVNFLE9BQVQsQ0FBa0IsR0FBRUMsU0FBSSxlQUFjQSxTQUFJLEVBQTFDLElBQStDLENBSHREO0FBSUg7O0FBR2MsU0FBU1Asa0JBQVQsQ0FBNkJRLEdBQTdCLEVBQWtDO0FBQzdDLFFBQUlBLFFBQVFBLElBQUlDLGVBQUosSUFBdUJELGVBQWVFLG1CQUE5QyxDQUFKLEVBQ0ksT0FBT0YsR0FBUDs7QUFFSixRQUFJQSxPQUFPQSxJQUFJRyxXQUFKLEtBQW9CQyxpQkFBL0IsRUFDSSxPQUFPLElBQUlDLGdDQUFKLENBQTRCTCxJQUFJTSxVQUFoQyxFQUE0Q04sSUFBSU8sUUFBaEQsQ0FBUDs7QUFFSixRQUFJUCxlQUFlUSxLQUFuQixFQUEwQjtBQUN0QixjQUFNQyxtQkFBbUJULElBQUlVLElBQUosS0FBYSxnQkFBYixJQUFpQ1YsSUFBSUcsV0FBSixDQUFnQk8sSUFBaEIsS0FBeUIsZ0JBQW5GOztBQUVBO0FBQ0E7QUFDQSxjQUFNSCxXQUFXRSxtQkFBbUIsc0NBQW9CVCxHQUFwQixFQUF5Qk4sNkJBQXpCLENBQW5CLEdBQTZFLHNDQUFvQk0sR0FBcEIsQ0FBOUY7O0FBRUEsZUFBT1MsbUJBQ0gsSUFBSUUsc0NBQUosQ0FBa0NYLEdBQWxDLEVBQXVDTyxRQUF2QyxDQURHLEdBRUgsSUFBSUYsZ0NBQUosQ0FBNEJMLEdBQTVCLEVBQWlDTyxRQUFqQyxDQUZKO0FBR0g7O0FBRUQsV0FBTyxJQUFJSyx5Q0FBSixDQUFxQ1osR0FBckMsQ0FBUDtBQUNIIiwiZmlsZSI6ImVycm9ycy9wcm9jZXNzLXRlc3QtZm4tZXJyb3IuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBzZXAgfSBmcm9tICdwYXRoJztcbmltcG9ydCB7IGdldENhbGxzaXRlRm9yRXJyb3IgfSBmcm9tICcuL2dldC1jYWxsc2l0ZSc7XG5pbXBvcnQgeyBBUElFcnJvciB9IGZyb20gJy4vcnVudGltZSc7XG5pbXBvcnQgVGVzdENhZmVFcnJvckxpc3QgZnJvbSAnLi9lcnJvci1saXN0JztcblxuaW1wb3J0IHtcbiAgICBVbmNhdWdodEVycm9ySW5UZXN0Q29kZSxcbiAgICBVbmNhdWdodE5vbkVycm9yT2JqZWN0SW5UZXN0Q29kZSxcbiAgICBFeHRlcm5hbEFzc2VydGlvbkxpYnJhcnlFcnJvclxufSBmcm9tICcuL3Rlc3QtcnVuJztcblxuXG5jb25zdCBJTlRFUk5BTCA9ICdpbnRlcm5hbC8nO1xuXG5mdW5jdGlvbiBpc0Fzc2VydGlvbkVycm9yQ2FsbHNpdGVGcmFtZSAoZnJhbWUpIHtcbiAgICBjb25zdCBmaWxlbmFtZSA9IGZyYW1lLmdldEZpbGVOYW1lKCk7XG5cbiAgICAvLyBOT1RFOiBmaWx0ZXIgb3V0IHRoZSBpbnRlcm5hbHMgb2Ygbm9kZS5qcyBhbmQgYXNzZXJ0aW9uIGxpYnJhcmllc1xuICAgIHJldHVybiBmaWxlbmFtZSAmJlxuICAgICAgICAgICBmaWxlbmFtZS5pbmRleE9mKHNlcCkgPiAtMSAmJlxuICAgICAgICAgICBmaWxlbmFtZS5pbmRleE9mKElOVEVSTkFMKSAhPT0gMCAmJlxuICAgICAgICAgICBmaWxlbmFtZS5pbmRleE9mKGAke3NlcH1ub2RlX21vZHVsZXMke3NlcH1gKSA8IDA7XG59XG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcHJvY2Vzc1Rlc3RGbkVycm9yIChlcnIpIHtcbiAgICBpZiAoZXJyICYmIChlcnIuaXNUZXN0Q2FmZUVycm9yIHx8IGVyciBpbnN0YW5jZW9mIFRlc3RDYWZlRXJyb3JMaXN0KSlcbiAgICAgICAgcmV0dXJuIGVycjtcblxuICAgIGlmIChlcnIgJiYgZXJyLmNvbnN0cnVjdG9yID09PSBBUElFcnJvcilcbiAgICAgICAgcmV0dXJuIG5ldyBVbmNhdWdodEVycm9ySW5UZXN0Q29kZShlcnIucmF3TWVzc2FnZSwgZXJyLmNhbGxzaXRlKTtcblxuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBjb25zdCBpc0Fzc2VydGlvbkVycm9yID0gZXJyLm5hbWUgPT09ICdBc3NlcnRpb25FcnJvcicgfHwgZXJyLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBc3NlcnRpb25FcnJvcic7XG5cbiAgICAgICAgLy8gTk9URTogYXNzZXJ0aW9uIGxpYnJhcmllcyBjYW4gYWRkIHRoZWlyIHNvdXJjZSBmaWxlcyB0byB0aGUgZXJyb3Igc3RhY2sgZnJhbWVzLlxuICAgICAgICAvLyBXZSBzaG91bGQgc2tpcCB0aGVtIHRvIGNyZWF0ZSBhIGNvcnJlY3QgY2FsbHNpdGUgZm9yIHRoZSBhc3NlcnRpb24gZXJyb3IuXG4gICAgICAgIGNvbnN0IGNhbGxzaXRlID0gaXNBc3NlcnRpb25FcnJvciA/IGdldENhbGxzaXRlRm9yRXJyb3IoZXJyLCBpc0Fzc2VydGlvbkVycm9yQ2FsbHNpdGVGcmFtZSkgOiBnZXRDYWxsc2l0ZUZvckVycm9yKGVycik7XG5cbiAgICAgICAgcmV0dXJuIGlzQXNzZXJ0aW9uRXJyb3IgP1xuICAgICAgICAgICAgbmV3IEV4dGVybmFsQXNzZXJ0aW9uTGlicmFyeUVycm9yKGVyciwgY2FsbHNpdGUpIDpcbiAgICAgICAgICAgIG5ldyBVbmNhdWdodEVycm9ySW5UZXN0Q29kZShlcnIsIGNhbGxzaXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IFVuY2F1Z2h0Tm9uRXJyb3JPYmplY3RJblRlc3RDb2RlKGVycik7XG59XG4iXX0=
