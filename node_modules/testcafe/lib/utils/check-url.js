'use strict';

exports.__esModule = true;

exports.default = function (url, rules) {
    if (!Array.isArray(rules)) rules = [rules];

    return rules.some(rule => urlMatchRule(parseUrl(url), prepareRule(rule)));
};

var _lodash = require('lodash');

const startsWithWildcardRegExp = /^\*\./;
const endsWithWildcardRegExp = /\.\*$/;
const trailingSlashesRegExp = /\/.*$/;
const portRegExp = /:(\d+)$/;
const protocolRegExp = /^(\w+):\/\//;
const wildcardRegExp = /\\\.\\\*/g;

function parseUrl(url) {
    if (!url || typeof url !== 'string') return null;

    let protocol = url.match(protocolRegExp);

    protocol = protocol ? protocol[1] : null;
    url = url.replace(protocolRegExp, '');
    url = url.replace(trailingSlashesRegExp, '');

    let port = url.match(portRegExp);

    port = port ? parseInt(port[1], 10) : null;
    url = url.replace(portRegExp, '');

    return { protocol, url, port };
}

function prepareRule(url) {
    const rule = parseUrl(url);

    if (rule) {
        rule.url = rule.url.replace(startsWithWildcardRegExp, '.');
        rule.url = rule.url.replace(endsWithWildcardRegExp, '.');
    }

    return rule;
}

function urlMatchRule(sourceUrl, rule) {
    if (!sourceUrl || !rule) return false;

    const matchByProtocols = !rule.protocol || !sourceUrl.protocol || rule.protocol === sourceUrl.protocol;
    const matchByPorts = !rule.port || sourceUrl.port === rule.port;
    const domainRequiredBeforeRule = rule.url.startsWith('.');
    const domainRequiredAfterRule = rule.url.endsWith('.');

    let regExStr = '^';

    if (domainRequiredBeforeRule) regExStr += '.+';

    regExStr += (0, _lodash.escapeRegExp)(rule.url).replace(wildcardRegExp, '\\..*');

    if (domainRequiredAfterRule) regExStr += '.+';

    regExStr += '$';

    return new RegExp(regExStr).test(sourceUrl.url) && matchByProtocols && matchByPorts;
}

module.exports = exports['default'];
//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9jaGVjay11cmwuanMiXSwibmFtZXMiOlsidXJsIiwicnVsZXMiLCJBcnJheSIsImlzQXJyYXkiLCJzb21lIiwicnVsZSIsInVybE1hdGNoUnVsZSIsInBhcnNlVXJsIiwicHJlcGFyZVJ1bGUiLCJzdGFydHNXaXRoV2lsZGNhcmRSZWdFeHAiLCJlbmRzV2l0aFdpbGRjYXJkUmVnRXhwIiwidHJhaWxpbmdTbGFzaGVzUmVnRXhwIiwicG9ydFJlZ0V4cCIsInByb3RvY29sUmVnRXhwIiwid2lsZGNhcmRSZWdFeHAiLCJwcm90b2NvbCIsIm1hdGNoIiwicmVwbGFjZSIsInBvcnQiLCJwYXJzZUludCIsInNvdXJjZVVybCIsIm1hdGNoQnlQcm90b2NvbHMiLCJtYXRjaEJ5UG9ydHMiLCJkb21haW5SZXF1aXJlZEJlZm9yZVJ1bGUiLCJzdGFydHNXaXRoIiwiZG9tYWluUmVxdWlyZWRBZnRlclJ1bGUiLCJlbmRzV2l0aCIsInJlZ0V4U3RyIiwiUmVnRXhwIiwidGVzdCJdLCJtYXBwaW5ncyI6Ijs7OztrQkE4RGUsVUFBVUEsR0FBVixFQUFlQyxLQUFmLEVBQXNCO0FBQ2pDLFFBQUksQ0FBQ0MsTUFBTUMsT0FBTixDQUFjRixLQUFkLENBQUwsRUFDSUEsUUFBUSxDQUFDQSxLQUFELENBQVI7O0FBRUosV0FBT0EsTUFBTUcsSUFBTixDQUFXQyxRQUFRQyxhQUFhQyxTQUFTUCxHQUFULENBQWIsRUFBNEJRLFlBQVlILElBQVosQ0FBNUIsQ0FBbkIsQ0FBUDtBQUNILEM7O0FBbkVEOztBQUVBLE1BQU1JLDJCQUEyQixPQUFqQztBQUNBLE1BQU1DLHlCQUEyQixPQUFqQztBQUNBLE1BQU1DLHdCQUEyQixPQUFqQztBQUNBLE1BQU1DLGFBQTJCLFNBQWpDO0FBQ0EsTUFBTUMsaUJBQTJCLGFBQWpDO0FBQ0EsTUFBTUMsaUJBQTJCLFdBQWpDOztBQUVBLFNBQVNQLFFBQVQsQ0FBbUJQLEdBQW5CLEVBQXdCO0FBQ3BCLFFBQUksQ0FBQ0EsR0FBRCxJQUFRLE9BQU9BLEdBQVAsS0FBZSxRQUEzQixFQUNJLE9BQU8sSUFBUDs7QUFFSixRQUFJZSxXQUFXZixJQUFJZ0IsS0FBSixDQUFVSCxjQUFWLENBQWY7O0FBRUFFLGVBQVdBLFdBQVdBLFNBQVMsQ0FBVCxDQUFYLEdBQXlCLElBQXBDO0FBQ0FmLFVBQVdBLElBQUlpQixPQUFKLENBQVlKLGNBQVosRUFBNEIsRUFBNUIsQ0FBWDtBQUNBYixVQUFXQSxJQUFJaUIsT0FBSixDQUFZTixxQkFBWixFQUFtQyxFQUFuQyxDQUFYOztBQUVBLFFBQUlPLE9BQU9sQixJQUFJZ0IsS0FBSixDQUFVSixVQUFWLENBQVg7O0FBRUFNLFdBQU9BLE9BQU9DLFNBQVNELEtBQUssQ0FBTCxDQUFULEVBQWtCLEVBQWxCLENBQVAsR0FBK0IsSUFBdEM7QUFDQWxCLFVBQU9BLElBQUlpQixPQUFKLENBQVlMLFVBQVosRUFBd0IsRUFBeEIsQ0FBUDs7QUFFQSxXQUFPLEVBQUVHLFFBQUYsRUFBWWYsR0FBWixFQUFpQmtCLElBQWpCLEVBQVA7QUFDSDs7QUFFRCxTQUFTVixXQUFULENBQXNCUixHQUF0QixFQUEyQjtBQUN2QixVQUFNSyxPQUFPRSxTQUFTUCxHQUFULENBQWI7O0FBRUEsUUFBSUssSUFBSixFQUFVO0FBQ05BLGFBQUtMLEdBQUwsR0FBV0ssS0FBS0wsR0FBTCxDQUFTaUIsT0FBVCxDQUFpQlIsd0JBQWpCLEVBQTJDLEdBQTNDLENBQVg7QUFDQUosYUFBS0wsR0FBTCxHQUFXSyxLQUFLTCxHQUFMLENBQVNpQixPQUFULENBQWlCUCxzQkFBakIsRUFBeUMsR0FBekMsQ0FBWDtBQUNIOztBQUVELFdBQU9MLElBQVA7QUFDSDs7QUFFRCxTQUFTQyxZQUFULENBQXVCYyxTQUF2QixFQUFrQ2YsSUFBbEMsRUFBd0M7QUFDcEMsUUFBSSxDQUFDZSxTQUFELElBQWMsQ0FBQ2YsSUFBbkIsRUFDSSxPQUFPLEtBQVA7O0FBRUosVUFBTWdCLG1CQUEyQixDQUFDaEIsS0FBS1UsUUFBTixJQUFrQixDQUFDSyxVQUFVTCxRQUE3QixJQUF5Q1YsS0FBS1UsUUFBTCxLQUFrQkssVUFBVUwsUUFBdEc7QUFDQSxVQUFNTyxlQUEyQixDQUFDakIsS0FBS2EsSUFBTixJQUFjRSxVQUFVRixJQUFWLEtBQW1CYixLQUFLYSxJQUF2RTtBQUNBLFVBQU1LLDJCQUEyQmxCLEtBQUtMLEdBQUwsQ0FBU3dCLFVBQVQsQ0FBb0IsR0FBcEIsQ0FBakM7QUFDQSxVQUFNQywwQkFBMkJwQixLQUFLTCxHQUFMLENBQVMwQixRQUFULENBQWtCLEdBQWxCLENBQWpDOztBQUVBLFFBQUlDLFdBQVcsR0FBZjs7QUFFQSxRQUFJSix3QkFBSixFQUNJSSxZQUFZLElBQVo7O0FBRUpBLGdCQUFZLDBCQUFTdEIsS0FBS0wsR0FBZCxFQUFtQmlCLE9BQW5CLENBQTJCSCxjQUEzQixFQUEyQyxPQUEzQyxDQUFaOztBQUVBLFFBQUlXLHVCQUFKLEVBQ0lFLFlBQVksSUFBWjs7QUFFSkEsZ0JBQVksR0FBWjs7QUFFQSxXQUFPLElBQUlDLE1BQUosQ0FBV0QsUUFBWCxFQUFxQkUsSUFBckIsQ0FBMEJULFVBQVVwQixHQUFwQyxLQUE0Q3FCLGdCQUE1QyxJQUFnRUMsWUFBdkU7QUFDSCIsImZpbGUiOiJ1dGlscy9jaGVjay11cmwuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBlc2NhcGVSZWdFeHAgYXMgZXNjYXBlUmUgfSBmcm9tICdsb2Rhc2gnO1xuXG5jb25zdCBzdGFydHNXaXRoV2lsZGNhcmRSZWdFeHAgPSAvXlxcKlxcLi87XG5jb25zdCBlbmRzV2l0aFdpbGRjYXJkUmVnRXhwICAgPSAvXFwuXFwqJC87XG5jb25zdCB0cmFpbGluZ1NsYXNoZXNSZWdFeHAgICAgPSAvXFwvLiokLztcbmNvbnN0IHBvcnRSZWdFeHAgICAgICAgICAgICAgICA9IC86KFxcZCspJC87XG5jb25zdCBwcm90b2NvbFJlZ0V4cCAgICAgICAgICAgPSAvXihcXHcrKTpcXC9cXC8vO1xuY29uc3Qgd2lsZGNhcmRSZWdFeHAgICAgICAgICAgID0gL1xcXFxcXC5cXFxcXFwqL2c7XG5cbmZ1bmN0aW9uIHBhcnNlVXJsICh1cmwpIHtcbiAgICBpZiAoIXVybCB8fCB0eXBlb2YgdXJsICE9PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBsZXQgcHJvdG9jb2wgPSB1cmwubWF0Y2gocHJvdG9jb2xSZWdFeHApO1xuXG4gICAgcHJvdG9jb2wgPSBwcm90b2NvbCA/IHByb3RvY29sWzFdIDogbnVsbDtcbiAgICB1cmwgICAgICA9IHVybC5yZXBsYWNlKHByb3RvY29sUmVnRXhwLCAnJyk7XG4gICAgdXJsICAgICAgPSB1cmwucmVwbGFjZSh0cmFpbGluZ1NsYXNoZXNSZWdFeHAsICcnKTtcblxuICAgIGxldCBwb3J0ID0gdXJsLm1hdGNoKHBvcnRSZWdFeHApO1xuXG4gICAgcG9ydCA9IHBvcnQgPyBwYXJzZUludChwb3J0WzFdLCAxMCkgOiBudWxsO1xuICAgIHVybCAgPSB1cmwucmVwbGFjZShwb3J0UmVnRXhwLCAnJyk7XG5cbiAgICByZXR1cm4geyBwcm90b2NvbCwgdXJsLCBwb3J0IH07XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVSdWxlICh1cmwpIHtcbiAgICBjb25zdCBydWxlID0gcGFyc2VVcmwodXJsKTtcblxuICAgIGlmIChydWxlKSB7XG4gICAgICAgIHJ1bGUudXJsID0gcnVsZS51cmwucmVwbGFjZShzdGFydHNXaXRoV2lsZGNhcmRSZWdFeHAsICcuJyk7XG4gICAgICAgIHJ1bGUudXJsID0gcnVsZS51cmwucmVwbGFjZShlbmRzV2l0aFdpbGRjYXJkUmVnRXhwLCAnLicpO1xuICAgIH1cblxuICAgIHJldHVybiBydWxlO1xufVxuXG5mdW5jdGlvbiB1cmxNYXRjaFJ1bGUgKHNvdXJjZVVybCwgcnVsZSkge1xuICAgIGlmICghc291cmNlVXJsIHx8ICFydWxlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICBjb25zdCBtYXRjaEJ5UHJvdG9jb2xzICAgICAgICAgPSAhcnVsZS5wcm90b2NvbCB8fCAhc291cmNlVXJsLnByb3RvY29sIHx8IHJ1bGUucHJvdG9jb2wgPT09IHNvdXJjZVVybC5wcm90b2NvbDtcbiAgICBjb25zdCBtYXRjaEJ5UG9ydHMgICAgICAgICAgICAgPSAhcnVsZS5wb3J0IHx8IHNvdXJjZVVybC5wb3J0ID09PSBydWxlLnBvcnQ7XG4gICAgY29uc3QgZG9tYWluUmVxdWlyZWRCZWZvcmVSdWxlID0gcnVsZS51cmwuc3RhcnRzV2l0aCgnLicpO1xuICAgIGNvbnN0IGRvbWFpblJlcXVpcmVkQWZ0ZXJSdWxlICA9IHJ1bGUudXJsLmVuZHNXaXRoKCcuJyk7XG5cbiAgICBsZXQgcmVnRXhTdHIgPSAnXic7XG5cbiAgICBpZiAoZG9tYWluUmVxdWlyZWRCZWZvcmVSdWxlKVxuICAgICAgICByZWdFeFN0ciArPSAnLisnO1xuXG4gICAgcmVnRXhTdHIgKz0gZXNjYXBlUmUocnVsZS51cmwpLnJlcGxhY2Uod2lsZGNhcmRSZWdFeHAsICdcXFxcLi4qJyk7XG5cbiAgICBpZiAoZG9tYWluUmVxdWlyZWRBZnRlclJ1bGUpXG4gICAgICAgIHJlZ0V4U3RyICs9ICcuKyc7XG5cbiAgICByZWdFeFN0ciArPSAnJCc7XG5cbiAgICByZXR1cm4gbmV3IFJlZ0V4cChyZWdFeFN0cikudGVzdChzb3VyY2VVcmwudXJsKSAmJiBtYXRjaEJ5UHJvdG9jb2xzICYmIG1hdGNoQnlQb3J0cztcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKHVybCwgcnVsZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocnVsZXMpKVxuICAgICAgICBydWxlcyA9IFtydWxlc107XG5cbiAgICByZXR1cm4gcnVsZXMuc29tZShydWxlID0+IHVybE1hdGNoUnVsZShwYXJzZVVybCh1cmwpLCBwcmVwYXJlUnVsZShydWxlKSkpO1xufVxuIl19
